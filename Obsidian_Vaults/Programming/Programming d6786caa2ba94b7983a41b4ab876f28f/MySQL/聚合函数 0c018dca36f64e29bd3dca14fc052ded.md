# 聚合函数

`SQL` 函数还有一类，叫做聚合（或聚集、分组）函数，它是对一组数据进行汇总的函数，输入的是一组数据的集合，输出的是**单个值**。

**注意：** 聚合函数不能嵌套调用。比如不能出现类似 `AVG(SUM(字段名称))` 形式的调用。

## 常用的函数

### `avg()` & `sum()`

只能用于数值运算，不考虑 `null` 值，直接跳过。如果要计算真正的平均值，直接用 `sum()` 除以总人数就可。

```sql
mysql> select avg(salary),sum(salary)
    -> from employees;
+-------------+-------------+
| avg(salary) | sum(salary) |
+-------------+-------------+
| 6422.427778 |   693622.20 |
+-------------+-------------+
1 row in set (0.00 sec)
```

### `max()` & `min()`

只要是能排序的就可用

```sql
mysql> select max(salary),min(salary) from employees;
+-------------+-------------+
| max(salary) | min(salary) |
+-------------+-------------+
|    24000.00 |     2100.00 |
+-------------+-------------+
1 row in set (0.00 sec)

mysql> select max(hire_date),min(last_name) from employees;
+----------------+----------------+
| max(hire_date) | min(last_name) |
+----------------+----------------+
| 2019-10-13     | Abel           |
+----------------+----------------+
1 row in set (0.00 sec)
```

### `count()`

用于计算指定字段在查询结果中的个数，如果是 `null` 就不算了。

```sql
mysql> select count(employee_id),count(commission_pct) from employees;#有的人是努力了
+--------------------+-----------------------+
| count(employee_id) | count(commission_pct) |
+--------------------+-----------------------+
|                108 |                    36 |
+--------------------+-----------------------+
1 row in set (0.00 sec)
```

### 小总结

```sql
mysql> select avg(salary),sum(salary)/count(salary),avg(commission_pct),sum(commission_pct)/count(commission_pct),sum(commission_pct)
    -> from employees e ;
+-------------+---------------------------+---------------------+-------------------------------------------+---------------------+
| avg(salary) | sum(salary)/count(salary) | avg(commission_pct) | sum(commission_pct)/count(commission_pct) | sum(commission_pct) |
+-------------+---------------------------+---------------------+-------------------------------------------+---------------------+
| 6422.427778 |               6422.427778 |            0.219722 |                                  0.219722 |                 7.91|
+-------------+---------------------------+---------------------+-------------------------------------------+---------------------+
1 row in set (0.00 sec)
```

关系： `AVG() = SUM() / COUNT()` 

### 关于 `count` 计算行数的效率

有三个选择： `count(*)` `count(1)` `count(具体字段)` ，注意，具体字段中不能含 `null` 

- 如果使用 `MyISAM` 引擎，效率相同，均为 `O(1)`
- 如果使用 `InnoDB` 引擎，`count(*)` = `count(1)` > `count(具体字段)` （尽量使用 `count(*)` ）

## `group by()`

声明在 `where` 后面， `order by` 前面

### 使用一个条件分组

场景：查询各个部门的 平均工资 & 最高工资

```sql
mysql> select department_id,avg(salary),max(salary)
    -> from employees
    -> group by department_id;
+---------------+--------------+-------------+
| department_id | avg(salary)  | max(salary) |
+---------------+--------------+-------------+
|          NULL |  7000.000000 |     7000.00 |#null的老哥们均在这个组里面
|            10 |  4400.000000 |     4400.00 |
|            20 |  9500.000000 |    13000.00 |
|            30 |  4150.000000 |    11000.00 |
|            40 |  6500.000000 |     6500.00 |
|            50 |  3475.555556 |     8200.00 |
|            60 |  5760.000000 |     9000.00 |
|            70 | 10000.000000 |    10000.00 |
|            80 |  8955.882353 |    14000.00 |
|            90 | 15055.550000 |    24000.00 |
|           100 |  8600.000000 |    12000.00 |
|           110 | 10150.000000 |    12000.00 |
+---------------+--------------+-------------+
12 rows in set (0.01 sec)
```

### 使用多个条件分组

场景：找出不同部门中不同工种的 平均&最高 工资

```sql
mysql> select department_id,job_id,avg(salary),max(salary)
    -> from employees
    -> group by department_id,job_id;#顺序无所谓，结果一致
+---------------+------------+--------------+-------------+
| department_id | job_id     | avg(salary)  | max(salary) |
+---------------+------------+--------------+-------------+
|            90 | AD_VP      | 12074.066667 |    17000.00 |
|            90 | AD_PRES    | 24000.000000 |    24000.00 |
|            60 | IT_PROG    |  5760.000000 |     9000.00 |
|           100 | FI_MGR     | 12000.000000 |    12000.00 |
|           100 | FI_ACCOUNT |  7920.000000 |     9000.00 |
|            30 | PU_MAN     | 11000.000000 |    11000.00 |
|            30 | PU_CLERK   |  2780.000000 |     3100.00 |
|            50 | ST_MAN     |  7280.000000 |     8200.00 |
|            50 | ST_CLERK   |  2785.000000 |     3600.00 |
|            80 | SA_MAN     | 12200.000000 |    14000.00 |
|            80 | SA_REP     |  8396.551724 |    11500.00 |
|          NULL | SA_REP     |  7000.000000 |     7000.00 |
|            50 | SH_CLERK   |  3215.000000 |     4200.00 |
|            10 | AD_ASST    |  4400.000000 |     4400.00 |
|            20 | MK_MAN     | 13000.000000 |    13000.00 |
|            20 | MK_REP     |  6000.000000 |     6000.00 |
|            40 | HR_REP     |  6500.000000 |     6500.00 |
|            70 | PR_REP     | 10000.000000 |    10000.00 |
|           110 | AC_MGR     | 12000.000000 |    12000.00 |
|           110 | AC_ACCOUNT |  8300.000000 |     8300.00 |
+---------------+------------+--------------+-------------+
20 rows in set (0.00 sec)
```

### 一个小问题

如果只用 `department_id` 进行分组，那就会出现一个组里面存在多个 `job_id` 此时， `MySQL` 只会给我们保留一个 `job_id` ，显然是不合适的，但是 **并不会报错** 。

```sql
mysql> select department_id,job_id,avg(salary),max(salary)
    -> from employees
    -> group by department_id;#此处没有选择 job_id
+---------------+---------+--------------+-------------+
| department_id | job_id  | avg(salary)  | max(salary) |
+---------------+---------+--------------+-------------+
|          NULL | SA_REP  |  7000.000000 |     7000.00 |
|            10 | AD_ASST |  4400.000000 |     4400.00 |
|            20 | MK_MAN  |  9500.000000 |    13000.00 |
|            30 | PU_MAN  |  4150.000000 |    11000.00 |
|            40 | HR_REP  |  6500.000000 |     6500.00 |
|            50 | ST_MAN  |  3475.555556 |     8200.00 |
|            60 | IT_PROG |  5760.000000 |     9000.00 |
|            70 | PR_REP  | 10000.000000 |    10000.00 |
|            80 | SA_MAN  |  8955.882353 |    14000.00 |
|            90 | AD_VP   | 15055.550000 |    24000.00 |
|           100 | FI_MGR  |  8600.000000 |    12000.00 |
|           110 | AC_MGR  | 10150.000000 |    12000.00 |
+---------------+---------+--------------+-------------+
12 rows in set (0.00 sec)
```

**注意：** `select` 里面的字段，必须声明在 `group bu` 中！

### `with rollup`

在 `group up` 后面加上 `with rollup` 之后， `MySQL` 会自动计算整体的数据，并加到最后一行。

下面的例子， `with rollup` 就计算了，整个公司的平均工资以及最高工资。

**注意：** 由于 `with rollup` 加入了额外的一行，就尽量别使用 `group up` 进行排序！

```sql
mysql> select department_id,avg(salary),max(salary)
    -> from employees
    -> group by department_id with rollup;
+---------------+--------------+-------------+
| department_id | avg(salary)  | max(salary) |
+---------------+--------------+-------------+
|          NULL |  7000.000000 |     7000.00 |
|            10 |  4400.000000 |     4400.00 |
|            20 |  9500.000000 |    13000.00 |
|            30 |  4150.000000 |    11000.00 |
|            40 |  6500.000000 |     6500.00 |
|            50 |  3475.555556 |     8200.00 |
|            60 |  5760.000000 |     9000.00 |
|            70 | 10000.000000 |    10000.00 |
|            80 |  8955.882353 |    14000.00 |
|            90 | 15055.550000 |    24000.00 |
|           100 |  8600.000000 |    12000.00 |
|           110 | 10150.000000 |    12000.00 |
|          NULL |  6422.427778 |    24000.00 |
+---------------+--------------+-------------+
13 rows in set (0.00 sec)

mysql> select department_id,avg(salary) avg_sal,max(salary)
    -> from employees
    -> group by department_id with rollup
    -> order by avg_sal asc;
+---------------+--------------+-------------+
| department_id | avg_sal      | max(salary) |
+---------------+--------------+-------------+
|            50 |  3475.555556 |     8200.00 |
|            30 |  4150.000000 |    11000.00 |
|            10 |  4400.000000 |     4400.00 |
|            60 |  5760.000000 |     9000.00 |
|          NULL |  6422.427778 |    24000.00 |
|            40 |  6500.000000 |     6500.00 |
|          NULL |  7000.000000 |     7000.00 |
|           100 |  8600.000000 |    12000.00 |
|            80 |  8955.882353 |    14000.00 |
|            20 |  9500.000000 |    13000.00 |
|            70 | 10000.000000 |    10000.00 |
|           110 | 10150.000000 |    12000.00 |
|            90 | 15055.550000 |    24000.00 |
+---------------+--------------+-------------+
13 rows in set (0.00 sec)
```

## `having`

类似于 `where` ，但是放在 `group by` 的后面。 **注意：** 一般情况下只有使用 `group by` 的情况下才使用 `having` 。

### 如果过滤条件中存在聚合函数，就一定要使用 `having` 来替换 `where`

**场景1**：查询平均工资大于10000的部门信息 

```sql
mysql> select department_id,avg(salary) avg_sal,max(salary)
    -> from employees
    -> where avg_sal>100  #使用 where 报错
    -> group by department_id;
ERROR 1054 (42S22): Unknown column 'avg_sal' in 'where clause'

mysql> select department_id,avg(salary) avg_sal,max(salary)
    -> from employees
    -> group by department_id
    -> having avg_sal > 10000; #跟在 group by 的后面
+---------------+--------------+-------------+
| department_id | avg_sal      | max(salary) |
+---------------+--------------+-------------+
|            90 | 15055.550000 |    24000.00 |
|           110 | 10150.000000 |    12000.00 |
+---------------+--------------+-------------+
2 rows in set (0.00 sec)
```

**场景2**：查询 部门id 是 10 20 30 40 中，最高工资比10000高的。

1. 方法一： `where` + `having`
    
    ```sql
     mysql> select department_id, max(salary) "ma"
        -> from employees
        -> where department_id in (10,20,30,40)
        -> group by department_id
        -> having ma > 10000;
    +---------------+----------+
    | department_id | ma       |
    +---------------+----------+
    |            20 | 13000.00 |
    |            30 | 11000.00 |
    +---------------+----------+
    2 rows in set (0.00 sec)
    ```
    
2. 方法二：仅使用 `having` 
    
    ```sql
    mysql> select department_id, max(salary) "ma"
        -> from employees
        -> group by department_id
        -> having ma > 10000 and department_id in (10,20,30,40);
    +---------------+----------+
    | department_id | ma       |
    +---------------+----------+
    |            20 | 13000.00 |
    |            30 | 11000.00 |
    +---------------+----------+
    2 rows in set (0.00 sec)
    ```
    
3. 结论： 过滤条件有聚合函数的时候，必须将过滤条件声明在 `having` 中。 但没有聚合函数的时候，可以声明在 `where` 中，也可以声明在 `having` 中，不过考虑到秩序效率，建议声明在 `where` 中。

**备注：** 由于 `where` 是先筛选再连接， `having` 是先连接再筛选， `where` 之后，整体的数据量会小很多，因此建议多使用 `where` ，以减小资源的消耗。

![Untitled](Programming/Programming%20d6786caa2ba94b7983a41b4ab876f28f/MySQL/聚合函数%200c018dca36f64e29bd3dca14fc052ded/Untitled.png)

## `SQL` 的运行方式

### 语句的书写顺序

```sql
#方式1：
SELECT ...,....,...
FROM ...,...,....
WHERE 多表的连接条件
AND 不包含组函数的过滤条件
GROUP BY ...,...
HAVING 包含组函数的过滤条件
ORDER BY ... ASC/DESC
LIMIT ...,...

#方式2：
SELECT ...,....,...
FROM ... JOIN ...
ON 多表的连接条件
JOIN ...
ON ...
WHERE 不包含组函数的过滤条件
AND/OR 不包含组函数的过滤条件
GROUP BY ...,...
HAVING 包含组函数的过滤条件
ORDER BY ... ASC/DESC
LIMIT ...,...
```

### 语句的执行顺序

FROM -> WHERE -> GROUP BY -> HAVING -> SELECT 的字段 -> DISTINCT -> ORDER BY -> LIMIT

1.  `from` 如果存在多表查询的情况，会先做笛卡尔积再根据 `on` 或 `where` 中的规则过滤。
2.  `where` 被滤掉的信息不参与后面的计算，由于分组在下一步，无法使用分组后的数据。
3.  `group by` 将多行聚合成一行，如果有的行在上一步被过滤，将会加快分组和二次过滤的效率。
4.  `having` 再过滤一次信息
5.  `select` 将不需要的列丢弃，在此处声明列的别名，无法在 `where` 中使用！
6.  `distinct` 将数据去重
7.  `order by`  排序
8.  `limit` 将其他的数据去除