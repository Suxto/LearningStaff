# 多表查询

多表查询，也称为关联查询，指**两个或更多个表**一起完成查询操作。

前提条件：这些一起查询的表之间是有关系的（一对一、一对多），它们之间一定是有关联字段，这个关联字段可能建立了外键，也可能没有建立外键。

比如：员工表和部门表，这两个表依靠“部门编号”进行关联。

# 引入

## 查询方式

### 笛卡尔积( `cross join` )的错误

![Untitled](Programming/Programming%20d6786caa2ba94b7983a41b4ab876f28f/MySQL/多表查询%20ab06c18473c14eb5850d2407e5828b41/Untitled.png)

**场景：** 将每个员工的部门地址查出来

```sql
select employee_id,department_name
from employees,departments ;#错误示范
#这个查出来的条数是员工数*部门数，将每个人和每个部门id都匹配了一次

#下面的代码和上面的是等效的
select employee_id,department_name
from employees cross join departments ;

```

**关于笛卡尔积**： 

笛卡尔乘积是一个数学运算。假设我有两个集合 X 和 Y，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有**可能组合**，也就是第一个对象来自于 X，第二个对象来自于 Y 的所有可能。组合的个数即为两个集合中元素个数的乘积数。

![Untitled](Programming/Programming%20d6786caa2ba94b7983a41b4ab876f28f/MySQL/多表查询%20ab06c18473c14eb5850d2407e5828b41/Untitled%201.png)

图中的情况是：$2\times 2\times2=8$ 种情况。

**出现笛卡尔积错误的情况**：

- 省略多个表的连接条件（或关联条件）
- 连接条件（或关联条件）无效
- 所有表中的所有行互相连接

### 如何解决呢

这个问题出现的本质原因是没有指定链接条件。

只要指定 `where employees.department_id=departments.department_id;` 作为连接条件，就可。

注意：如果遇到 `department_id` 是 `null` 的员工，就不会显示到结果里面。

```sql
mysql> select employee_id,department_name
    -> from employees,departments
    -> where employees.department_id=departments.department_id;
+-------------+------------------+
| employee_id | department_name  |
+-------------+------------------+
|         200 | Administration   |
|         162 | Sales            |
|         163 | Sales            |
..................................
|         206 | Accounting       |
+-------------+------------------+
107 rows in set (0.00 sec)
```

### 还有一个问题

一个字段出现在多张表的情况：必须指明具体字段存在哪张表！

```sql
mysql> select employee_id,department_name,department_id
    -> from employees , departments
    -> where employees.department_id =departments.department_id ;
ERROR 1052 (23000): Column 'department_id' in field list is ambiguous 
#ambiguous是不明确的意思

mysql> select employee_id,department_name,**employees.department_id**
    -> from employees , departments
    -> where employees.department_id =departments.department_id ;
+-------------+------------------+---------------+
| employee_id | department_name  | department_id |
+-------------+------------------+---------------+
|         200 | Administration   |            10 |
|         201 | Marketing        |            20 |
.................................................
|         206 | Accounting       |           110 |
+-------------+------------------+---------------+
107 rows in set (0.00 sec)
```

**建议：** 从优化角度来说，多表查询的适合最好指定每个字段的表名。

### 表的别名

表的名字太长会减弱SQL语句的可读性，此时可以起别名，直接跟在表的后面就好。

**注意**： 如果起了别名，必须在后面的语句中使用别名，使用原名会报错！

```sql
select **emp**.employee_id,**dep**.department_name,**dep**.department_id 
from employees **emp**, departments **dep**
where **emp**.department_id =**dep**.department_id ;
```

### 多个条件连接

在 `where` 语句中，使用 `and` 来连接多个关系：如果查询设计到$n$个表的关系，至少要有$n-1$个查询条件。

```sql
mysql> select e.employee_id,e.last_name ,d.department_name,d.department_id,l.city
    -> from employees e, departments d,locations l
    -> where e.department_id =d.department_id
    -> **and** d.location_id =l.location_id ;
+-------------+-------------+------------------+---------------+---------------------+
| employee_id | last_name   | department_name  | department_id | city                |
+-------------+-------------+------------------+---------------+---------------------+
|         200 | Whalen      | Administration   |            10 | Seattle             |
|         201 | Hartstein   | Marketing        |            20 | Toronto             |
|         110 | Chen        | Finance          |           100 | Seattle             |
......................................................................................
|         206 | Gietz       | Accounting       |           110 | Seattle             |
+-------------+-------------+------------------+---------------+---------------------+
107 rows in set (0.00 sec)
```

# 分类

## 等值连接&非等值连接

等值连接连接两个相等的值，而非等值则匹配区间。

**场景：** 将工资与工资等级相匹配。

```sql
mysql> select * from job_grades;#工资等级表
+-------------+------------+-------------+
| grade_level | lowest_sal | highest_sal |
+-------------+------------+-------------+
| A           |       1000 |        2999 |
| B           |       3000 |        5999 |
| C           |       6000 |        9999 |
| D           |      10000 |       14999 |
| E           |      15000 |       24999 |
| F           |      25000 |       40000 |
+-------------+------------+-------------+
6 rows in set (0.00 sec)

mysql> select first_name,salary,grade_level
    -> from employees,job_grades
    -> where salary between lowest_sal and highest_sal
    -> limit 4;
+------------+----------+-------------+
| first_name | salary   | grade_level |
+------------+----------+-------------+
| h_hh       |  2222.20 | A           |
| Steven     | 24000.00 | E           |
| Neena      | 17000.00 | E           |
| Lex        | 17000.00 | E           |
+------------+----------+-------------+
4 rows in set (0.00 sec)
```

## 自连接&非自连接

前面实现的是非自连接，都是多张表之间的连接。自连接指的是同一张表中连接。

**自连接场景：** `employees` 表里面记录了一个人的员工id和上级id。于是我们可以用自连接将每个员工与其上司连接在一起。

```sql
mysql> select emp.employee_id,emp.last_name,mgr.employee_id,mgr.last_name
    -> from employees emp,employees mgr
    -> where emp.manager_id=mgr.employee_id
    -> limit 5;
+-------------+-----------+-------------+-----------+
| employee_id | last_name | employee_id | last_name |
+-------------+-----------+-------------+-----------+
|           1 | h_hh      |           1 | h_hh      |
|         101 | Kochhar   |         100 | King      |
|         102 | De Haan   |         100 | King      |
|         103 | Hunold    |         102 | De Haan   |
|         104 | Ernst     |         103 | Hunold    |
+-------------+-----------+-------------+-----------+
5 rows in set (0.00 sec)
```

逻辑上 `employees` 是两张不同的表，在自连接的时候要注意要将每个列来自哪一张表写清楚！

## 内连接&外连接

**内连接**： 合并具有同一列的两个以上的表的行, 结果集中**不包**含一个表与另一个表**不匹配的行**

**外连接：** 两个表在连接过程中除了返回满足连接条件的行以外还返回**左（或右）**表中不满足条件的
行 ，这种连接称为**左（或右）** 外连接。没有匹配的行时, 结果表中相应的列为空 `NULL` 。于是外连接，就分为了 **左外连接 右外连接 & 满外连接。**

### 对于 `SQL 92` 语法：使用 `+` 。

不过在 `MySQL` 中有个**小**问题，它不支持 `SQL92` 😓。而且 `SQL92` 不支持 **满外连接** 。

```sql
 #左外连接
SELECT last_name,department_name
FROM employees ,departments
WHERE employees.department_id = departments.department_id(+);
#对 缺少 对应数据的那张表+一下，就可以了

#右外连接
SELECT last_name,department_name
FROM employees ,departments
WHERE employees.department_id(+) = departments.department_id;
```

### 对于 `SQL99` 语法，我们使用 `join ... on ..` 语法。

1. **内连接**： `from 表1 join 表2 on 匹配条件` 可以嵌套多个。 `inner join` 中的 `inner` 可以省略。
    
    ```sql
    mysql> select emp.employee_id,emp.last_name,mgr.employee_id,mgr.last_name
        -> from employees emp [inner] join employees mgr
        -> on emp.manager_id=mgr.employee_id
        -> limit 4;
    +-------------+-----------+-------------+-----------+
    | employee_id | last_name | employee_id | last_name |
    +-------------+-----------+-------------+-----------+
    |           1 | h_hh      |           1 | h_hh      |
    |         101 | Kochhar   |         100 | King      |
    |         102 | De Haan   |         100 | King      |
    |         103 | Hunold    |         102 | De Haan   |
    +-------------+-----------+-------------+-----------+
    4 rows in set (0.00 sec)
    ```
    
2. **外连接：  `outer join`** 
    
    ```sql
    mysql> select last_name,department_name
        -> from employees e **left** join departments d #左外连接，查询所有员工
        -> on e.department_id=d.department_id
        -> limit 4;
    +-----------+-----------------+
    | last_name | department_name |
    +-----------+-----------------+
    | h_hh      | Executive       |
    | King      | Executive       |
    | Kochhar   | Executive       |
    | De Haan   | Executive       |
    +-----------+-----------------+
    4 rows in set (0.00 sec)
    
    mysql> select last_name,department_name
        -> from employees e right join departments d #右外连接，查询所有部门
        -> on e.department_id=d.department_id
        -> limit 4;
    +-----------+-----------------+
    | last_name | department_name |
    +-----------+-----------------+
    | Whalen    | Administration  |
    | Hartstein | Marketing       |
    | Fay       | Marketing       |
    | Raphaely  | Purchasing      |
    +-----------+-----------------+
    4 rows in set (0.00 sec)
    ```
    
3. **满外连接** `full outer join` 这个是 `SQL99` 的标准，但是 `MySQL` 不支持 `Oracal` 支持。于是我们只能曲线救国。于是引出了 `union` 关键字的使用。
    
    **合并查询结果:** 利用`UNION`关键字，可以给出多条`SELECT`语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列数和数据类型必须相同，并且相互对应。各个`SELECT`语句之间使用 `union` 或 `union all` 关键字分隔。
    
    1.  `union` 关键字
        
        ![Untitled](Programming/Programming%20d6786caa2ba94b7983a41b4ab876f28f/MySQL/多表查询%20ab06c18473c14eb5850d2407e5828b41/Untitled%202.png)
        
        将A与B的结果并起来，然后再对**并集部分去重**。由于去重的操作十分的消耗资源，建议能不用就不用。 **注意：** `union` 连接的是两个完整的 `select` 语句。
        
        ```sql
        mysql> select employee_id,department_name from employees e left join departments d on e.department_id=d.department_id
            -> union
            -> select employee_id,department_name from employees e right join departments d on e.department_id=d.department_id;
        +-------------+----------------------+
        | employee_id | department_name      |
        +-------------+----------------------+
        |         178 | NULL                 |
        |         200 | Administration       |
        |        NULL | Retail Sales         |
        |        NULL | Recruiting           |
        |        NULL | Payroll              |
        +-------------+----------------------+
        **124** rows in set (0.00 sec)
        ```
        
    2.  `union all` 关键字
        
        ![Untitled](Programming/Programming%20d6786caa2ba94b7983a41b4ab876f28f/MySQL/多表查询%20ab06c18473c14eb5850d2407e5828b41/Untitled%203.png)
        
        `union all` 关键字不会对并集部分进行去重，好处是 **快** ，建议尽可能多使用这个关键字。
        
        ```sql
        mysql> select employee_id,department_name from employees e left join departments d on e.department_id=d.department_id
            -> union all
            -> select employee_id,department_name from employees e right join departments d on e.department_id=d.department_id;
        +-------------+----------------------+
        | employee_id | department_name      |
        +-------------+----------------------+
        |         178 | NULL                 |
        |        NULL | Government Sales     |
        |        NULL | Retail Sales         |
        |        NULL | Recruiting           |
        |        NULL | Payroll              |
        +-------------+----------------------+
        **231** rows in set (0.00 sec)#此处由于没有对并集部分去重，数据多了很多。
        ```
        
    3.  `SQL` 标准的 `join` 关键字
        
        ![Untitled](Programming/Programming%20d6786caa2ba94b7983a41b4ab876f28f/MySQL/多表查询%20ab06c18473c14eb5850d2407e5828b41/Untitled%204.png)
        
        实现 `left join union right join` 的方式有很多种。
        
        ```sql
        #左上图加右下图
        mysql> select employee_id,department_name from employees e left join departments d on e.department_id=d.department_id
            -> union all
            -> select employee_id,department_name from employees e right join departments d on e.department_id=d.department_id
            -> where e.department_id is null; #指向B独有的部分。
        +-------------+----------------------+
        | employee_id | department_name      |
        +-------------+----------------------+
        |         178 | NULL                 |
        |         200 | Administration       |
        |        NULL | Retail Sales         |
        |        NULL | Recruiting           |
        |        NULL | Payroll              |
        +-------------+----------------------+
        **124** rows in set (0.00 sec)
        
        #左中图加右上
        #略。。。
        ```
        
        # `SQL 99` 新特性
        
        ## 自然连接
        
        `SQL99` 在 `SQL92` 的基础上提供了一些特殊语法，比如 `NATURAL JOIN` 用来表示自然连接。我们可以把自然连接理解为 `SQL92` 中的等值连接。它会帮你自动查询两张连接表中**所有相同**的字段 ，然后进行 **等值连接** 。
        
        ### `SQL 92` 中：
        
        ```sql
        mysql> SELECT employee_id,last_name,department_name
            -> FROM employees e JOIN departments d
            -> ON e.`department_id` = d.`department_id`
            -> AND e.`manager_id` = d.`manager_id`;
        +-------------+------------+-----------------+
        | employee_id | last_name  | department_name |
        +-------------+------------+-----------------+
        |         101 | Kochhar    | Executive       |
        |         202 | Fay        | Marketing       |
        |         206 | Gietz      | Accounting      |
        +-------------+------------+-----------------+
        **32** rows in set (0.00 sec)
        ```
        
        ### `SQL 99` 中:
        
        ```sql
        mysql> SELECT employee_id,last_name,department_name
            -> FROM employees e **NATURAL JOIN** departments d;
        +-------------+------------+-----------------+
        | employee_id | last_name  | department_name |
        +-------------+------------+-----------------+
        |         202 | Fay        | Marketing       |
        |         115 | Khoo       | Purchasing      |
        |         116 | Baida      | Purchasing      |
        |         206 | Gietz      | Accounting      |
        +-------------+------------+-----------------+
        32 rows in set (0.00 sec)
        ```
        
        `MySQL` 会找出两张表中所有的相同字段，然后进行匹配，等值连接。
        
        ### `using` 的使用
        
        ### `SQL 92` 中：
        
        ```sql
        mysql> SELECT employee_id,last_name,department_name
            -> FROM employees e ,departments d
            -> WHERE e.department_id = d.department_id;
        +-------------+-------------+------------------+
        | employee_id | last_name   | department_name  |
        +-------------+-------------+------------------+
        |         200 | Whalen      | Administration   |
        |         201 | Hartstein   | Marketing        |
        |         205 | Higgins     | Accounting       |
        |         206 | Gietz       | Accounting       |
        +-------------+-------------+------------------+
        107 rows in set (0.00 sec)
        ```
        
        ### `SQL 99` 中:
        
        ```sql
        mysql> SELECT employee_id,last_name,department_name
            -> FROM employees e JOIN departments d
            -> USING (department_id);#
        +-------------+-------------+------------------+
        | employee_id | last_name   | department_name  |
        +-------------+-------------+------------------+
        |         200 | Whalen      | Administration   |
        |         205 | Higgins     | Accounting       |
        |         206 | Gietz       | Accounting       |
        +-------------+-------------+------------------+
        107 rows in set (0.00 sec)
        ```
        
        `using` 关键字会自动匹配两张表里指定相同名字的字段。 **注意：** 自连接的时候别使用。