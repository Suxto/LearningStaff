# 子查询

SQL 中子查询的使用大大增强了 SELECT 查询的能力，因为很多时候查询需要从结果集中获取数据，或者需要从同一个表中先计算得出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集合）进行比较。

可以写子查询的位置：除了 `group by` 和 `limit` 之外都可以写子查询！

子查询在增删改查中都有广泛的应用，但是在查询的时候，尽量使用多表查询，效率更高。

## 需求分析&解决

### 实际问题

场景： 谁的工资比 Abel 高？

1. 方法一： 查两次，先查 Abel 的工资，再查询比这个数据更大的人。
    
    ```sql
    mysql> select salary from employees where last_name = 'Abel';
    +----------+
    | salary   |
    +----------+
    | 11000.00 |
    +----------+
    1 row in set (0.00 sec)
    
    mysql> select last_name,salary from employees where salary >11000;
    +-----------+----------+
    | last_name | salary   |
    +-----------+----------+
    | King      | 24000.00 |
    | Kochhar   | 17000.00 |
    | De Haan   | 17000.00 |
    | Greenberg | 12000.00 |
    | Russell   | 14000.00 |
    | Partners  | 13500.00 |
    | Errazuriz | 12000.00 |
    | Ozer      | 11500.00 |
    | Hartstein | 13000.00 |
    | Higgins   | 12000.00 |
    +-----------+----------+
    10 rows in set (0.00 sec)
    ```
    
2. 方法二： 自连接
    
    ```sql
    mysql> select e2.last_name,e2.salary
        -> from employees e1, employees e2
        -> where e2.salary>e1.salary and e1.last_name='Abel';
    +-----------+----------+
    | last_name | salary   |
    +-----------+----------+
    | King      | 24000.00 |
    | Kochhar   | 17000.00 |
    | De Haan   | 17000.00 |
    | Greenberg | 12000.00 |
    | Russell   | 14000.00 |
    | Partners  | 13500.00 |
    | Errazuriz | 12000.00 |
    | Ozer      | 11500.00 |
    | Hartstein | 13000.00 |
    | Higgins   | 12000.00 |
    +-----------+----------+
    10 rows in set (0.00 sec)
    ```
    
3. 方法三： 子查询
    
    ```sql
    mysql> SELECT last_name,salary
        -> FROM employees
        -> WHERE salary > (
        -> SELECT salary
        -> FROM employees
        -> WHERE last_name = 'Abel'
        -> );
    +-----------+----------+
    | last_name | salary   |
    +-----------+----------+
    | King      | 24000.00 |
    | Kochhar   | 17000.00 |
    | De Haan   | 17000.00 |
    | Greenberg | 12000.00 |
    | Russell   | 14000.00 |
    | Partners  | 13500.00 |
    | Errazuriz | 12000.00 |
    | Ozer      | 11500.00 |
    | Hartstein | 13000.00 |
    | Higgins   | 12000.00 |
    +-----------+----------+
    10 rows in set (0.00 sec)
    ```
    

## 规范

外查询（主查询）、内查询（子查询）

- 子查询在主查询之前完成
- 子查询的结果被主查询所使用
- 注意：
    - 子查询在括号内
    - 子查询要放在比较条件的右侧（建议）
    - 单行操作符对应单行子查询，多行操作符对应多行子查询

## 分类

### 单行子查询 & 多行子查询

我们按内查询的结果返回**一条**还是**多条**记录，将子查询分为 单行子查询 、 多行子查询 。

![Untitled](Programming/Programming%20d6786caa2ba94b7983a41b4ab876f28f/MySQL/子查询%202179b4cabbf64e85baeafa8190a97c50/Untitled.png)

1. **单行子查询：**
    1. 单行比较符：  `=` `>` `<` `≥` `<=` `<>（不等于）`
    2. 编写思路：
        1. 从里往外写：先写好内层查询的语句（比如查询1号员工的工资），再将整个查询语句放入外层查询的筛选条件之中。
        2. 从外往里写：先写好查询的框架，再在过滤条件中查询需要的数据
    3. 子查询是 `null` 的时候不会返会任何行，也不会报错，最后的结果也是空的。
    4. 非法使用子查询：在子查询返回多行的时候，使用单行从比较符。
2. **多行子查询：**
    1. 多行比较符：
        1. `in` 等于列表中的**任意**一个
            
            场景：查询与任一部门最低工资相同工资的人名。
            
            ```sql
            mysql> select last_name
                -> from employees
                -> where salary in (select min(salary) from employees group by department_id)
                -> limit 5;
            +------------+
            | last_name  |
            +------------+
            | h_hh       |
            | Ernst      |
            | Lorentz    |
            | Popp       |
            | Colmenares |
            +------------+
            5 rows in set (0.00 sec)
            ```
            
        2. `any/some` 需要和单行比较操作符一起使用，和子查询返回的**某一个值**比较
            
            场景：返回其它 `job_id` 中比 `job_id` 为 `‘IT_PROG’` 部门任一工资低的员工的员工号、姓名、job_id 以及 salary
            
            ```sql
            mysql> select employee_id,last_name,job_id,salary
                -> from employees
                -> where job_id <> 'IT_PROG' and
                -> salary < any (select salary from employees where job_id = 'IT_PROG')
                -> limit 5;
            +-------------+-----------+------------+---------+
            | employee_id | last_name | job_id     | salary  |
            +-------------+-----------+------------+---------+
            |         206 | Gietz     | AC_ACCOUNT | 8300.00 |
            |         200 | Whalen    | AD_ASST    | 4400.00 |
            |           1 | h_hh      | AD_VP      | 2222.20 |
            |         110 | Chen      | FI_ACCOUNT | 8200.00 |
            |         111 | Sciarra   | FI_ACCOUNT | 7700.00 |
            +-------------+-----------+------------+---------+
            5 rows in set (0.00 sec)
            ```
            
        3. `all` 需要和单行比较操作符一起使用，和子查询返回的**所有值**比较
            
            场景1：返回其它 `job_id` 中比 `job_id` 为 `‘IT_PROG’` 部门所有工资都低的员工的员工号、姓名、job_id 以及 salary
            
            ```sql
            mysql> select employee_id,last_name,job_id,salary
                -> from employees
                -> where job_id <> 'IT_PROG' and
                -> salary < all (select salary from employees where job_id = 'IT_PROG')
                -> limit 5;
            +-------------+-----------+----------+---------+
            | employee_id | last_name | job_id   | salary  |
            +-------------+-----------+----------+---------+
            |           1 | h_hh      | AD_VP    | 2222.20 |
            |         115 | Khoo      | PU_CLERK | 3100.00 |
            |         116 | Baida     | PU_CLERK | 2900.00 |
            |         117 | Tobias    | PU_CLERK | 2800.00 |
            |         118 | Himuro    | PU_CLERK | 2600.00 |
            +-------------+-----------+----------+---------+
            5 rows in set (0.00 sec)
            ```
            
            场景2：找出平均工资最低的部门id
            
            ```sql
            #方法一：直接上
            mysql> select department_id
                -> from employees
                -> group by department_id
                -> having avg(salary) <= all (select avg(salary) from employees group by department_id);
            +---------------+
            | department_id |
            +---------------+
            |            50 |
            +---------------+
            1 row in set (0.00 sec)
            
            #方法二：曲线救国，将平均值作为一张表，再从里面查最小值
            mysql> select department_id
                -> from employees e
                -> group by department_id
                -> having avg(salary) = (
                ->                              select min(avg_sal)
                ->                              from (
                ->                                      select avg(salary) avg_sal
                ->                                      from employees e2
                ->                                      group by department_id
                ->                              ) as sal_avg_table
                ->                              );
            +---------------+
            | department_id |
            +---------------+
            |            50 |
            +---------------+
            1 row in set (0.00 sec)
            ```
            
    2. 空值问题（尽量使子查询的结果不含 `null` ）
        
        场景：查询不是管理者的员工id
        
        ```sql
        #子查询中存在 null
        mysql> select employee_id
            -> from employees
            -> where employee_id not in (select manager_id from employees);
        Empty set (0.00 sec)
        #排除 null 的值之后
        mysql> select employee_id
            -> from employees
            -> where employee_id not in (select manager_id from employees 
        		-> where manager_id is not null);
        +-------------+
        | employee_id |
        +-------------+
        |         104 |
        |         105 |
        |         206 |
        +-------------+
        89 rows in set (0.00 sec)
        ```
        

### 相关子查询 & 非相关子查询

子查询执行 一次 或 多次

1. **相关子查询**
    1. 场景：查询工资大于**所在部门**平均工资的员工信息，此处的平均工资是变动的，每个部门的平均工资应该是不一样的。
    2. 查询流程：
        
        ![Untitled](Programming/Programming%20d6786caa2ba94b7983a41b4ab876f28f/MySQL/子查询%202179b4cabbf64e85baeafa8190a97c50/Untitled%201.png)
        
        相关子查询按照一行接一行的顺序执行，主查询的**每一行**都执行一次子查询。
        
    3. 示例
        1. 查询员工中工资大于本部门平均工资的员工的last_name,salary和其department_id
            
            ```sql
            #方法1：相关子查询
            mysql> select last_name,salary,department_id
                -> from employees e1
                -> where salary > (
                ->                          select avg(salary)
                ->                          from employees e2
            																#此处使用外部的表
                ->                          where e2.department_id = e1.department_id
                ->                  )
                -> limit 5;
            +-----------+----------+---------------+
            | last_name | salary   | department_id |
            +-----------+----------+---------------+
            | King      | 24000.00 |            90 |
            | Kochhar   | 17000.00 |            90 |
            | De Haan   | 17000.00 |            90 |
            | Hunold    |  9000.00 |            60 |
            | Ernst     |  6000.00 |            60 |
            +-----------+----------+---------------+
            5 rows in set (0.00 sec)
            
            #方法2：再from中声明子查询
            SELECT last_name,salary,e1.department_id
            FROM employees e1,(SELECT department_id,AVG(salary) dept_avg_sal FROM employees GROUP
            BY department_id) e2 #这表里面有每个部门的平均工资
            WHERE e1.`department_id` = e2.department_id
            AND e2.dept_avg_sal < e1.`salary`;
            ```
            
        2. 查询员工的id,salary,按照department_name 排序
            
            ```sql
            mysql> select employee_id,salary
                -> from employees e
                -> order by (#直接将子查询写在 order by 里面，根据每一条的department_id 查询
                ->          select department_name
                ->          from departments d
                ->          where e.department_id=d.department_id)
                -> limit 5;
            +-------------+----------+
            | employee_id | salary   |
            +-------------+----------+
            |         178 |  7000.00 |
            |         206 |  8300.00 |
            |         205 | 12000.00 |
            |         200 |  4400.00 |
            |         100 | 24000.00 |
            +-------------+----------+
            5 rows in set (0.00 sec)
            ```
            
        3. 若 employees 表中 `employee_id` 与 `job_history` 表中 `employee_id` 相同的数目不小于**2**，输出这些相同id的员工的`employee_id` , `last_name` 和其 `job_id`
            
            ```sql
            mysql> select employee_id,last_name,job_id
                -> from employees e
                -> where  2<=(
                ->          select count(*)
                ->          from job_history j
                ->          where j.employee_id=e.employee_id);
            +-------------+-----------+---------+
            | employee_id | last_name | job_id  |
            +-------------+-----------+---------+
            |         101 | Kochhar   | AD_VP   |
            |         176 | Taylor    | SA_REP  |
            |         200 | Whalen    | AD_ASST |
            +-------------+-----------+---------+
            3 rows in set (0.01 sec)
            ```
            
    4. `EXISTS` 与 `NOT EXISTS` 关键字
        1. 关联子查询通常也会和 `EXISTS` 操作符一起来使用，用来检查在子查询中是否存在满足条件的行。
            1. 如果在子查询中不存在满足条件的行：
                - 条件返回 FALSE
                - 继续在子查询中查找
            2. 如果在子查询中存在满足条件的行：
                - 不在子查询中继续查找
                - 条件返回 TRUE
            
            `NOT EXISTS` 关键字表示如果**不存在**某种条件，则返回TRUE，否则返回FALSE。
            
        2. 场景1：查询公司管理者的employee_id，last_name，job_id，department_id信息
            
            ```sql
            #方法一：子查询
            mysql> select employee_id,last_name,job_id,department_id
                -> from employees
                -> where employee_id in (
                ->                  select manager_id
                ->                  from employees
                ->                  group by manager_id);
            +-------------+-----------+---------+---------------+
            | employee_id | last_name | job_id  | department_id |
            +-------------+-----------+---------+---------------+
            |           1 | h_hh      | AD_VP   |            90 |
            |         201 | Hartstein | MK_MAN  |            20 |
            |         205 | Higgins   | AC_MGR  |           110 |
            +-------------+-----------+---------+---------------+
            19 rows in set (0.00 sec)
            
            mysql> select employee_id,last_name,job_id,department_id
                -> from employees
                -> where employee_id in (
                ->                  select distinct manager_id
                ->                  from employees);
            +-------------+-----------+---------+---------------+
            | employee_id | last_name | job_id  | department_id |
            +-------------+-----------+---------+---------------+
            |           1 | h_hh      | AD_VP   |            90 |
            |         201 | Hartstein | MK_MAN  |            20 |
            |         205 | Higgins   | AC_MGR  |           110 |
            +-------------+-----------+---------+---------------+
            19 rows in set (0.00 sec)
            
            #方法二：自连接（记得去重)
            mysql> select distinct mgr.employee_id,mgr.last_name,mgr.job_id,mgr.department_id
                -> from employees e join employees mgr
                -> where e.manager_id=mgr.employee_id;
            +-------------+-----------+---------+---------------+
            | employee_id | last_name | job_id  | department_id |
            +-------------+-----------+---------+---------------+
            |           1 | h_hh      | AD_VP   |            90 |
            |         201 | Hartstein | MK_MAN  |            20 |
            |         205 | Higgins   | AC_MGR  |           110 |
            +-------------+-----------+---------+---------------+
            19 rows in set (0.00 sec)
            
            #方法三：exist
            #对每一个员工都去找员工表，如果有人的manager_id和当前记录的员工id一样，就输出这条记录
            mysql> select mgr.employee_id,mgr.last_name,mgr.job_id,mgr.department_id
                -> from employees mgr
                -> where exists (
                ->          select *
                ->          from employees e
                ->          where mgr.employee_id=e.manager_id);
            +-------------+-----------+---------+---------------+
            | employee_id | last_name | job_id  | department_id |
            +-------------+-----------+---------+---------------+
            |           1 | h_hh      | AD_VP   |            90 |
            |         201 | Hartstein | MK_MAN  |            20 |
            |         205 | Higgins   | AC_MGR  |           110 |
            +-------------+-----------+---------+---------------+
            19 rows in set (0.00 sec)
            ```
            
        3. 场景二：查询 departments 表中，不存在于 employees 表中的部门的 department_id 和department_name
            
            ```sql
            #方法一：外连接
            mysql> select d.department_id,d.department_name
                -> from departments d left join employees e
                -> on d.department_id=e.department_id
                -> where e.department_id is null;
            +---------------+----------------------+
            | department_id | department_name      |
            +---------------+----------------------+
            |           120 | Treasury             |
            |           270 | Payroll              |
            +---------------+----------------------+
            16 rows in set (0.00 sec)
            
            #方法二： not exist
            #找到没有员工的表
            where d.department_id=e.department_id)' at line 4
            mysql> select d.department_id,d.department_name
                -> from departments d
                -> where not exists (
                ->                  select *
                ->                  from employees e
                ->                  where d.department_id=e.department_id);
            +---------------+----------------------+
            | department_id | department_name      |
            +---------------+----------------------+
            |           120 | Treasury             |
            |           270 | Payroll              |
            +---------------+----------------------+
            16 rows in set (0.00 sec)
            
            #方法三：不相关子查询
            #记得将子查询中 null 的值去除！
            mysql> select department_name,d.department_id
                -> from departments d
                -> where d.department_id not in (
                ->                          select distinct e.department_id
                ->                           from employees e
                ->                           where e.department_id is not null
                ->                          );
            +----------------------+---------------+
            | department_name      | department_id |
            +----------------------+---------------+
            | Treasury             |           120 |
            | Payroll              |           270 |
            +----------------------+---------------+
            16 rows in set (0.00 sec)
            ```
            
2. **不相关子查询**
    1. 场景：查询工资大于**整个公司**平均工资的员工信息，此处的公司平均工资是变动的，每个人都只需要和公司的平均工资比较就可。
    2. 在前面的单&多行子查询中使用的均为不相关子查询。