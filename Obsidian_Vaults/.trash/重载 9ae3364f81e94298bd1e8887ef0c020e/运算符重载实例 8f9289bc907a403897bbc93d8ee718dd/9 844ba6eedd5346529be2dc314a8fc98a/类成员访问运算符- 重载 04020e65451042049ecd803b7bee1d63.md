# 类成员访问运算符->重载

`p->m` 被解释为 `(p.operator->())->m`

```cpp
#include <iostream>
#include <vector>
using namespace std;
// 假设一个实际的类
class Obj {
   static int i, j;
public:
   void f() const { cout << i++ << endl; }//在这输出
   void g() const { cout << j++ << endl; }
};
 
// 静态成员定义
int Obj::i = 10;
int Obj::j = 12;
 
// 为上面的类实现一个容器
class ObjContainer {
   vector<Obj*> a;//储存的是obj对象的指针
public:
   void add(Obj* obj){ 
      a.push_back(obj);  // 调用向量的标准方法
   }
   friend class SmartPointer;
};
 
// 实现智能指针，用于访问类 Obj 的成员
class SmartPointer {
   ObjContainer oc;
   int index;
public:
   SmartPointer(ObjContainer& objc){//构造函数
       oc = objc;
       index = 0;
   }
   // 返回值表示列表结束
   bool operator++(){ // 前缀版本
     if(index >= oc.a.size() - 1) return false;//向右越界
     if(oc.a[++index] == 0) return false;//向左越界
     return true;
   }
   bool operator++(int){ // 后缀版本
      return operator++();
   }
   // 重载运算符 ->
   Obj* operator->() const {
     if(!oc.a[index]){//若没有存值
        cout << "Zero value";
        return (Obj*)0;
     }
     return oc.a[index];//有值则返回对象指针
   }
};
 
int main() {
   const int sz = 10;
   Obj o[sz];
   ObjContainer oc;
   for(int i = 0; i < sz; i++){
       oc.add(&o[i]);//加入的是obj对象的指针
   }
   SmartPointer sp(oc); // 创建一个迭代器（对象）
   do {
      sp->f(); // 智能指针调用
      sp->g();
   } while(sp++);//如果越界则停止，++代表指针指向下一个对象
   return 0;
}
```

结果：

> 10
12
11
13
12
14
13
15
14
16
15
17
16
18
17
19
18
20
19
21
>