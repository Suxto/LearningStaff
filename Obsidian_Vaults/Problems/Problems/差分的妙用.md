How to make it: Tutorial
Tags: Differential, Greedy
Time Created: June 24, 2022 8:21 PM

[Problem - C - Codeforces](https://codeforces.com/contest/1700/problem/C)

### 思路：

    看到对区间的加减，就应该想到差分的了，我想到了，但是没想到是这样的。

    从题目本身出发，要是得最后的值全部都是$0$，应该首先保证数列中的数字都是一样的，因为我们可以对数列中的数字进行整体的加和减。这个时候，就轮到差分上场了。

1. 我们先新建一个数组 `diff[n]` 来记录每两个值之间的差。即： `diff[i]=v[i]-v[i-1]` 
2. 当 `diff[i]>0` 的时候，说明当前的数大于前一个数字，我们将后面的多的数字全部减掉（后一个已经和当前数字一样了），然后 `ans+=diff[i]` （操作 `diff[i]` 次）
3. 当 `diff[i]<0` 的时候，说明当前数字小于前一个数字，然后我们把前面的所有数字都减掉多余的部分，也就是 `ans-=diff[i]`（操作 `diff[i]` 次）次，然后 `diff[0]+=diff[i]` （本质上还是差分，我们操作减去前面的所有项的时候，最终会反映在 `diff[0]` 上。
4. 执行完之后，整个数列就是一样的数字
5. 把 `ans+=|diff[0]|` 就能将所有的数字变成$0$。

### 代码：

```cpp
#include <bits/stdc++.h>

using namespace std;
#define  endl '\n'
#define int long long
#define ll int64_t
#define MAXN 1000
typedef pair<int, int> pii;

void solve() {
	int n;
	cin >> n;
	vector<int> v(n), diff(n), c(n);
	for(int &i : v) cin >> i;
	diff[0] = v[0];
	for(int i = 1; i < n; i++) {
		diff[i] = v[i] - v[i - 1];
	}
	int ans = 0;
	for(int i = n - 1; i > 0; i--) {
		if(diff[i] > 0) {
			// c[i] -= diff[i];
			ans += diff[i];
		} else if(diff[i] < 0) {
			// c[i] += diff[i];
			// c[0] -= diff[i];
			ans -= diff[i];
			diff[0] += diff[i];
		}
	}
	cout << ans + llabs(diff[0]) << endl;
}

signed main() {
	cin.tie(nullptr)->sync_with_stdio(false);
	int t = 1;
//	scanf("%lld", &t);
	cin >> t;
	while (t--) solve();
}
```