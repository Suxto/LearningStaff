How to make it: Tutorial
Tags: DP, Graph
Time Created: August 21, 2022 6:41 PM

[https://ac.nowcoder.com/acm/contest/38630/F](https://ac.nowcoder.com/acm/contest/38630/F)

**思路**

    每个公司，都是一个树。然后全部公司合起来就是一个森林，对于排列的种类数，我们可以使用可重集排列。

- 可重集排列
    
    比如一个序列： $[1,2,2,3,3,3,4,4,4,4]$的排列数是 $\frac{10!}{1! \times 2! \times 3!\times 4!}$，有几个相同的部分就乘几次，相当于用总的排列除去相同部分的排列。
    

     如果对整个树使用可重集排序，可以拆解为对每个节点排序。每个节点的总儿子个数代表着这个节点下有多少个人排序，而每个子节点的长度代表着顺序没有影响的人数。于是就能推导出每个节点的计算公式：

$$
dp[x]=(size[x]-1)!\cdot\prod_{i \in son(x)}\frac{dp[i]}{(size[i])!}
$$

其中 $\prod dp[son]$ 指代的是每一个儿子的方案数，将他们连乘得到总的方案数，根据这个转移方程就可以写出代码。

    PS. 单向遍历的话，每个关系只需要存一次，节约空间和时间。

- Code
    
    ```cpp
    #include <bits/stdc++.h>
    
    //#define debug
    #define MAXN 100010
    #define MOD 1000000007
    #define int long long
    #define double long double
    #define pos first
    #define val second
    #define dbg(x) cout << #x << " = " << x << endl
    #define endl '\n'
    using namespace std;
    typedef pair<int, int> pii;
    int fac[MAXN], inv[MAXN];
    
    int fstPow(int a, int b) {
        int ans = 1;
        while (b) {
            if (b & 1)
                ans = (ans * a) % MOD;
            b >>= 1;
            a = (a * a) % MOD;
        }
        return ans % MOD;
    }
    
    inline void init() {
        fac[0] = 1;
        for (int i = 1; i < MAXN; i++)
            fac[i] = fac[i - 1] * i % MOD;
    
        inv[MAXN - 1] = fstPow(fac[MAXN - 1], MOD - 2);
    
        for (int i = MAXN - 2; i >= 1; i--)
            inv[i] = (i + 1) * inv[i + 1] % MOD;
    }
    
    ostream &operator<<(ostream &o, const pii &p) {
        o << '<' << p.first << ',' << p.second << '>';
        return o;
    }
    
    template <typename T> ostream &operator<<(ostream &o, vector<T> &x) {
        o << "[";
        for (auto i = x.begin(); i < x.end(); ++i) {
            if (i != x.begin())
                o << ", ";
            o << *i /*<< ' '*/;
        }
        o << "]" << endl;
        return o;
    }
    
    vector<vector<int>> v;
    vector<int> siz, dp;
    
    void dfs(int now) {
        for (int &i : v[now]) {
            dfs(i);
            siz[now] += siz[i];
            dp[now] = (dp[now] * ((dp[i] * inv[siz[i]]) % MOD)) % MOD;
        }
        dp[now] = (dp[now] * fac[siz[now] - 1]) % MOD;
    }
    
    inline void solve() {
        int n, ans = 1ll, cnt = 0ll;
        cin >> n;
        for (int i = 1; i <= n; i++) {
            int sz;
            cin >> sz;
    
            cnt += sz;
            siz = dp = vector<int>(sz + 1, 1);
            v = vector<vector<int>>(sz + 1);
            for (int j = 2; j <= sz; j++) {
                int t;
                cin >> t;
                v[t].emplace_back(j);
                // v[j].emplace_back(t);
            }
            dfs(1);
            ans = (ans * ((dp[1] * inv[siz[1]]) % MOD)) % MOD;
        }
        ans %= MOD;
        ans = (ans * fac[cnt]) % MOD;
        cout << ans;
    }
    
    signed main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        cin.exceptions(std::istream::failbit);
        cout.tie(nullptr);
    
        init();
        int T = 1;
        // cin >> T;
        while (T--) {
            solve();
        }
        return 0;
    }
    ```