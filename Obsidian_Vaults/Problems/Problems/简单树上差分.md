How to make it: Tutorial
Tags: DFS, Differential, Graph
Time Created: August 9, 2022 1:54 PM

[https://ac.nowcoder.com/acm/contest/33191/B](https://ac.nowcoder.com/acm/contest/33191/B)

**思路：**

    通过这个题学习了如何储存图，双向存图是一个好的方法，分辨父子节点的方法是在 `DFS` 的时候，在参数列表中加入其父节点的下标值就好了。然后由于 `DFS` 算法的特殊性，差分肯定没法像传统方法那样使用前缀和的方式，但是可以转换下思路，将 `--` 的操作转换为判断有多少个点在当前节点完结，所有的子节点传回的个数减去当前节点完结的数就是可以接着往下传的数，利用 `DFS` 的回溯完成了差分算法，非常的精妙。

- Code
    
    ```cpp
    #include <bits/stdc++.h>
    
    #define MAXN 2000020
    #define int long long
    #define endl '\n'
    #define IO cin.tie(nullptr)->sync_with_stdio(0)
    using namespace std;
    vector<int> v[MAXN], rang(MAXN), chain, ans(MAXN), arr(MAXN);
    
    int dfs(int now, int pre) {
        int here = 1, len = (int)chain.size();
        int there = max(0ll, len - rang[now] - 1ll);
        arr[chain[there]]++;
        for (int &i : v[now]) {
            if (i != pre) {
                chain.emplace_back(i);
                here += dfs(i, now);
                chain.pop_back();
            }
        }
        ans[now] = here;
        here -= arr[now];
        arr[now] = 0; // restore
        return here;
    }
    
    void solve() {
        int n;
        cin >> n;
        for (int i = 1; i < n; i++) {
            int a, b;
            cin >> a >> b;
            v[a].emplace_back(b);
            v[b].emplace_back(a);
        }
        for (int i = 1; i <= n; i++) {
            cin >> rang[i];
        }
        chain.emplace_back(1);
        dfs(1, 0);
        chain.pop_back();
        for (int i = 1; i <= n; i++) {
            cout << ans[i] << ' ';
        }
        cout << '\n';
    }
    
    signed main() {
        IO;
        int T = 1;
        // cin >> T;
        while (T--)
            solve();
        return 0;
    }
    ```