How to make it: Tutorial
Tags: Binary
Time Created: June 12, 2022 2:14 PM

[Problem - D - Codeforces](https://codeforces.com/gym/103765/problem/D)

### 思路：

    为了能使尽可能多的猴子拿到不同的香蕉，我们应该给猴子分的香蕉树应该是等差数列。而等差数列越多，总香蕉数就越小。于是我们可以二分等差数列的个数（也就是持有相同香蕉的猴子个数），当这些等差数列的和大于香蕉的个数的时候，说明当前分法香蕉个数不够，需要增加等差数列的个数。当等差数列的和小于香蕉个数的时候，说明等差数列多了，需要减小等差数列的个数。

**PS**:

注意加上没有处于等差数列之中的香蕉数目。

$num=(m\mod mid)\times (m\div mid+1)$ 

其中，$(m \mod mid)$ 是分割成 $mid$ 个部分之后，剩下的香蕉数，$m\div mid$是分割部分的个数，因为是等差数列求和，所以要乘以分割的个数。

### code:

```cpp
#include <bits/stdc++.h>
using namespace std;
#define  endl '\n'
typedef long long ll;
const int MAXN = 1000007;

void slove() {
	ll b, m, l, r;
	cin >> b >> m;
	l = 1, r = m;
	while(l < r) {
		ll mid = (l + r) / 2;
		ll sum = ((1 + m / mid) * (m / mid)) * mid / 2 ;
		ll sum = ((1 + m / mid) * m) >> 1;
		sum += (m % mid) * (m / mid + 1);//!
		if(sum <= b)r = mid;
		else l = mid + 1;
	}
	cout << r << endl;
}

int main() {
	// cin.tie(nullptr)->sync_with_stdio(false);
	int t ;
	cin >> t;
	while(t--) slove();
}
```