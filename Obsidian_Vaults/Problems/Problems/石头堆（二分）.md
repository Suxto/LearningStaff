How to make it: Tutorial
Tags: Binary
Time Created: January 2, 2022 1:26 PM

[Problem - 1623C - Codeforces](https://codeforces.com/problemset/problem/1623/C)

### 简述

一个石头堆，每个堆都承载着不同的石头。现在需要通过一定的操作使得石头堆的最小堆的数量达到最大 : c。

1. 选择一个d
2. 将前一个（i-1）堆的d个石头移向当前堆
3. 将前第二个（i-2）堆的2d个石头移向当前堆

### 思路

1. **总体设计：**看到了最小的最大这种东西，我们就应该想到枚举。由于我们根本没有办法再移动的时候就平衡每个堆石头的个数，我们只能猜测最小堆的个数最大能取到多少（肯定比初始的最大值要小）。但是实际上，题目只给了一秒，要对每个可能的值进行验证，显然会超时。于是我只能采取 **二分搜索** ，通过判断当前的x是否能通过测试来调整搜索的范围。如果能搜到（经过贪心的移动后，每个堆的数量都小于x），显然这个值是可以取的，我们就接着向更小的找。但是如果这个值娶不到，说明太大了，我们就往小了找。最终得到结果，这个可以用来加速一些有着明确分界的枚举问题。
2. 设计判断当前x是否成立的函数：这个题目不能按照他给的方法正向移动。如果按照题目的办法模拟的话，我们可能没有办法在每次移动的时候确认每一堆确切的数据。所以只能倒着来，但是有一个问题，倒着来的话可能会出现透支的问题，这个时候我们只能访问原始的数据集，在每次检查的时候都将数据集复制一次。

### Code

```cpp
#include<bits/stdc++.h>
#define MAXN 1000000
#define endl '\n'
#define IO ios::sync_with_stdio(false);cin.tie(0),cout.tie(0)
typedef long long ll;
using namespace std;
vector<ll> v;

bool chk(ll now) {
	vector<ll> v1(v);//每次复制一次数据
	//for (int i : v1)cout << i << endl;
	auto i = v.end() - 1;//反着来
	for (auto it = v1.end() - 1;it > v1.begin() + 1;it--, i--) {
		if (*it < now) return false;//如果有一个堆比最小值还要小，显然不可能
		ll d = min(*i, *it - now) / 3;
		*(it - 1) += d;
		*(it - 2) += d * 2;
	}
	if (v1[0] < now || v1[1] < now) return false;
	return true;
}

int main() {
	IO;
	int T;
	cin >> T;
	while (T--) {
		ll n, minp = 0, maxn = LONG_MIN;
		cin >> n;
		v.clear();
		for (int i = 0; i < n; i++) {
			ll temp;
			cin >> temp;
			maxn = max(maxn, temp);
			//if (temp < v[minp]) minp = i;
			v.push_back(temp);
		}
		chk(1);
		// if (minp == n - 1) {
		// 	cout << v[minp] << endl;
		// 	continue;
		// }
		//ll minn = v[minp];
		ll l = 0ll, r = maxn, mid;
		while (l < r) {//二分标准写法
			mid = (l + r + 1) >> 1;
			if (chk(mid)) l = mid;
			else r = mid - 1ll;
		}
		cout << l << endl;
	}
}
```