How to make it: Tutorial
Tags: Math
Time Created: November 5, 2021 10:16 PM

- Detail
    
    **Problem Statement**
    
    We have a large square grid with H*H* rows and W*W* columns. Iroha is now standing in the top-left cell. She will repeat going right or down to the adjacent cell, until she reaches the bottom-right cell.
    However, she cannot enter the cells in the intersection of the bottom A*A* rows and the leftmost B*B* columns. (That is, there are A×B*A*×*B* forbidden cells.) There is no restriction on entering the other cells.
    Find the number of ways she can travel to the bottom-right cell.
    Since this number can be extremely large, print the number modulo 10^9+7109+7.
    
    **Constraints**
    
    • 1 ≦ H, W ≦ 100,0001≦*H*,*W*≦100,000
    • 1 ≦ A < H1≦*A*<*H*
    • 1 ≦ B < W1≦*B*<*W*
    
    **Input**
    
    The input is given from Standard Input in the following format:
    
    `H*H* W*W* A*A* B*B*`
    
    **Output**
    
    Print the number of ways she can travel to the bottom-right cell, modulo 10^9+7109+7.
    
    **Sample Input 1**
    
    `2 3 1 1`
    
    **Sample Output 1**
    
    `2`
    
    **Sample Input 2**
    
    `10 7 3 4`
    
    **Sample Output 2**
    
    `3570`
    
    There are 1212 forbidden cells.
    
    **Sample Input 3**
    
    `100000 100000 99999 99999`
    
    **Sample Output 3**
    
    `1`
    
    **Sample Input 4**
    
    `100000 100000 44444 55555`
    
    **Sample Output 4**
    
    `738162020`
    
- **Intro**
    
    一块R*C的地方，有r*c块禁区，计算从左上到右下的路径数目。（每次移动向下或者向右）
    
    ![Untitled](Problems/Problems/别踩黑块（组合数）%20f058d5f90e564d9b85ff8a0198f253e7/Untitled.png)
    

**思路：**

有两条：

- 用一共的数目减去被阻挡的数
- 将所有能走的数加起来

Ps. 让我们复习一下这里的组合数怎么写：一共要移动n次，每一次向下或者向右，于是组合出来的数目就是一共的路线。比如下2右3，就是$C_{2+3}^2$。

注意：组合数的计算方法要高效！

[组合数(卢卡斯定理）](https://www.notion.so/0910ba756c7e495cae45407def575ec5)

- Code
    
    ```cpp
    #include<bits/stdc++.h>
    
    #define mod 1000000007
    typedef long long lol;
    using namespace std;
    
    lol quickPow(lol a, lol b) {
        lol ans = 1 % mod;
        while (b > 0) {
            if (b & 1) ans = ans * a % mod;
            a = a * a % mod;
            b = b >> 1;
        }
        return ans;
    }
    
    lol calc(lol n, lol k) {//c(n,k)
        if (k > n) return 0;
        if (k > (n >> 1))k = n - k;//c 5 3 --> c 5 2
        lol ret = 1 % mod;
        for (int i = 2; i <= n; i++) ret = ret * i % mod;
        for (int i = 2; i <= k; i++) ret = ret * quickPow(i, mod - 2) % mod;
        for (int i = 2; i <= n - k; i++)ret = ret * quickPow(i, mod - 2) % mod;
        return ret;
    }
    
    lol f[2000000];
    
    void init() {
        f[0] = 1;
        for (lol i = 1; i < 2000000; i++)
            f[i] = (f[i - 1] * i) % mod;
    }
    
    lol CC(lol n,lol m)
    {
        lol a=f[n];
        lol b=(f[m]*f[n-m])%mod;
        return (a*quickPow(b,mod-2))%mod;
    }
    
    int main() {
        ios::sync_with_stdio(false);
        cin.tie(0), cout.tie(0);
        //cout<< quickPow(2,3);
        init();
        lol R, C, r, c;
        cin >> R >> C >> r >> c;
        lol ans = 0;
        /*
        ans = calc(R + C - 2ll, R - 1ll);
        for (lol i = r; i > 0; i--) {
            ans = (ans - calc(R - i + c - 1ll, c - 1ll) * calc(C - c + i - 2ll, i - 1ll) % mod + mod) % mod;
        }
        */
        for (int i = 1; i <= R - r; i++) {
            //ans = (ans % mod + calc(c + i - 2, i - 1) * calc(R - i + C - c - 1, C - c - 1) % mod) % mod;
            ans = (ans % mod + CC(c + i - 2, i - 1) * CC(R - i + C - c - 1, C - c - 1) % mod) % mod;
        }
        cout << ans;
    }
    ```