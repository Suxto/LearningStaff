How to make it: Tutorial
Tags: Math
Time Created: January 4, 2022 9:02 PM

[Problem - B - Codeforces](https://codeforces.com/contest/1621/problem/B)

### 简述

有一堆数字区间，每一个区间都有自己的价格。商店很良心，只要买l和r的两个（或一个）区间，就可以获得他们之间的所有的数字。目标是，用最少的钱，买最多的数字。

### 思路

题目提到了，每上架一个数字区间，就要输出一个结果，所有没有必要一次将数据全部读入，边读边算就好了，还方便些。

如果完全模拟的话，要遍历$n^2$次显然超时了，于是只能转向新的方案。

因为题目的目标是达到最大的区间，所以最多用两个区间就够了。我们只要维护每一次的最小和最大值（最大区间），为了囊括一个区间搞定的情况，我们还要维护一个最长的区间（包括长度和价值）

只能说，还是一道比较好想的思维题。还是要多做题，不然什么都不会。主要是2s的时间有一定的迷惑性，我本来一位直接可以枚举出来hhh☹️

### EZ code

```cpp
#include<bits/stdc++.h>
#define MAXN INT_MAX
#define endl '\n'
#define IO ios::sync_with_stdio(false);cin.tie(0),cout.tie(0);
typedef long long ll;
using namespace std;

int main() {
    IO
    int T;
    cin >> T;
    while (T--) {
        int n;
        cin >> n;
        int minl = INT_MAX, maxr = INT_MIN;
        int lcost = INT_MAX, rcost = INT_MAX;
        int maxlen = INT_MIN, maxcost = INT_MAX;
        for (int i = 0; i < n; i++) {
            int l, r, c, ans;
            cin >> l >> r >> c;
            if (l < minl) minl = l, lcost = MAXN;
            if (l == minl) lcost = min(lcost, c);

            if (r > maxr) maxr = r, rcost = MAXN;
            if (r == maxr) rcost = min(rcost, c);

            if (r - l + 1 > maxlen) maxlen = r - l + 1, maxcost = MAXN;
            if (r - l + 1 == maxlen) maxcost = min(maxcost, c);

            ans = lcost + rcost;
            if (maxlen == maxr - minl + 1) ans =min( maxcost,ans);
            cout << ans << endl;
        }
    }
}
```

### sb超时code

```cpp
#include<bits/stdc++.h>
#define MAXN 1000000
#define endl '\n'
#define IO ios::sync_with_stdio(false);cin.tie(0),cout.tie(0);
typedef long long ll;
using namespace std;
struct node {
    int l, r, c;
    // bool operator() (const node& a, const node& b) const {
    // 	return a.c < b.c;
    // }
};

struct cmp {
    bool operator()(const node &a, const node &b) const {
        return a.c < b.c;
    }
};

vector<node> v;
set<node, cmp> s;

int main() {
    IO
    int T;
    cin >> T;
    while (T--) {
        int n;
        s.clear();
        cin >> n;
        int minl = INT_MAX, maxr = INT_MIN;
        for (int i = 0; i < n; i++) {
            int l, r, c;
            cin >> l >> r >> c;
            minl = min(minl, l);
            maxr = max(maxr, r);
            // v.push_back({ l, r, c });
            s.insert({l, r, c});

            if (i == 0) {
                cout << s.begin()->c << endl;
                continue;
            }
//            for (node nn: s) {
//                cout << nn.l << ' ' << nn.r << ' ' << nn.c << endl;
//            }
            //cout<<endl;
            int ans = INT_MAX;
            auto maxp = s.begin(), minp = s.begin();
            bool fl = false, fr = false;

            for (auto iterator = s.begin(); iterator != s.end(); iterator++) {
                if (iterator->l == minl) {
                    if (iterator->r == maxr) ans = iterator->c;
                    if (!fl) {
                        minp = iterator;
                        fl = true;
                    }
                }
                if (!fr && iterator->r == maxr) {
                    maxp = iterator;
                    fr = true;
                }
                if(fl&&fr) break;
            }
            ans = min(ans, maxp->c + minp->c);
            cout << ans << endl;
        }

    }
}
```