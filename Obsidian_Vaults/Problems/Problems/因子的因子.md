How to make it: Tutorial
Tags: Math
Time Created: September 20, 2022 5:22 PM

[Attachments - 2018-2019 ACM-ICPC, Asia Dhaka Regional Contest - Codeforces](https://codeforces.com/gym/102040/attachments)

[2021 GDUT Autumn Team_up Training III - Virtual Judge (vjudge.net)](https://vjudge.net/contest/459121#problem/C)

**思路**：

    每个数都分解质因数的话，都只有唯一的分解。而因子的因子显然也包括在数字本身的因子中，于是我们分析每个质数在 n 中的个数。

$$
n!=p_1^{k_1}\times p_2^{k_2}\times p_3^{k_3}\cdots p_n^{k_n}
$$

    每个$p_i$都有$\{0\}\{0,1\}\cdots \{0\cdots k_i\}$ 一共 $k_i+1$ 种选择，于是每个因数的贡献就能用等差数列求和得到$\frac{(1+k_i+1)(k_i+1)}{2}$。

    再把每个因数乘起来，就知道所有的因子的贡献值了。

    用 x 不断的除 一个质数，就能知道 x 所有有当前指数因子中当前质数总和的个数。

- Code
    
    ```cpp
    #include <bits/stdc++.h>
    
    #define int long long
    #define MOD 10000007
    #define MAXN 1000005
    #define endl '\n'
    using namespace std;
    #define IO ios::sync_with_stdio(false);\
        cin.tie(nullptr)
    double mx = 0;
    typedef pair<char, int> pii;
    
    ostream &operator<<(ostream &o, pii p) {
        o << '<' << (int) p.first << ',' << (int) p.second << '>';
        return o;
    }
    
    template<typename T>
    ostream &operator<<(ostream &o, vector<T> &x) {
        o << "[";
        for (auto i = x.begin(); i < x.end(); ++i) {
            if (i != x.begin()) o << ", ";
            o << *i /*<< ' '*/;
        }
        o << "]" << endl;
        return o;
    }
    
    template<typename T>
    istream &operator>>(istream &i, vector<T> &v) {
        for (auto it = v.begin(); it < v.end(); ++it) {
            cin >> *it;
    //        mx = max(mx, *it);
        }
        return i;
    }
    
    int prime[MAXN], cnt;
    bool st[MAXN];
    
    void getPrimes() {
        for (int i = 2; i < MAXN; i++) {
            if (!st[i]) prime[cnt++] = i;
            for (int j = 0; j < cnt && prime[j] <= MAXN / i; j++) {
                st[i * prime[j]] = true;
                if (i % prime[j] == 0) break;
            }
        }
    }
    
    void solve() {
        getPrimes();
        int n;
        cin >> n;
        while (n) {
            int ans = 1;
            for (int i = 0; i < cnt; i++) {
                if (n < prime[i]) break;
                int sum = 0, tmp = n;
                while (tmp)
                    sum += tmp = tmp / prime[i];
                ans = (ans % MOD) * ((sum + 1) * (sum + 2) >> 1) % MOD;
            }
            cout << ans % MOD << endl;
            cin >> n;
        }
    }
    
    signed main() {
        IO;
        int T = 1;
    //    cin >> T;
        while (T--) {
            solve();
        }
        return 0;
    }
    ```