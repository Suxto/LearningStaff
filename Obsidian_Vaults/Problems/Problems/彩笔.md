How to make it: Tutorial
Tags: DP
Time Created: August 12, 2022 1:03 PM

[https://codeforces.com/gym/102893/problem/D](https://codeforces.com/gym/102893/problem/D)

**思路：**

    一眼 `dp` 题， 通过 `dp` 来计算不同加和下的不同分块情况的种类数。设数组为 `dp[i][j]`  `i` 是出现的前i个数字， `j` 是使用数字的个数，新加入数字的时候通过转移方程。

$$
dp[i][j]=\sum^{\lfloor j/i\rfloor}_{t=0}C^t_{k+t-1}\cdot  dp[i-1][j-ti]
$$

    这里的组合数可以将新加入的 `t` 个 `i` 放在任何一个堆里面，可以使用隔板法。

    组合数的计算可以使用杨辉三角形优化

- 杨辉三角板子
    
    ```cpp
    void init(){
     
        for(int i = 0; i <= 30; ++i){
            for(int j = 0; j <= i; ++j){
                if(j == 0 || i == 0) C[i][j] = 1;
                else C[i][j] = C[i - 1][j] + C[i - 1][j - 1];
            }
        }
    }
    
    ————————————————
    版权声明：本文为CSDN博主「freeze up」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
    原文链接：https://blog.csdn.net/weixin_44059127/article/details/112647943
    ```
    
- Code
    
    ```cpp
    #include <bits/stdc++.h>
    
    #define MAXN 200000
    #define int long long
    using namespace std;
    int C[35][35], dp[33][33];
    
    void init() {
        for (int i = 0; i < 31; i++) {
            for (int j = 0; j <= i; j++) {
                if (j == 0 || i == 0)
                    C[i][j] = 1;
                else
                    C[i][j] = C[i - 1][j] + C[i - 1][j - 1];
            }
        }
    }
    
    void solve() {
        int n, k;
        init();
        cin >> n >> k;
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= n; j++) {
                for (int t = 0; t <= j / i; t++) {
                    dp[i][j] += dp[i - 1][j - t * i] * C[k + t - 1][t];
                }
            }
        }
        cout << dp[n][n];
    }
    signed main() {
        int T = 1;
        // std::cin >> T;
        while (T--) {
            solve();
        }
        return 0;
    }
    ```