How to make it: Tutorial
Tags: DP
Time Created: November 28, 2021 8:40 PM

[NWU2021新生训练附加题目01（请AK其他弹的哥哥来做题！） - Virtual Judge (ppsucxtt.cn)](https://vjudge.ppsucxtt.cn/contest/464282#problem/F)

[Problem - B - Codeforces (Unofficial mirror site, accelerated for Chinese users)](https://codeforces.ml/contest/1350/problem/B)

- Intro
    
    最长的上升子序列，而且要保证子序列的下标拥有相同因子。
    
- Detail
    
    ![Untitled](Problems/Problems/神奇最短上升子序列%200b0ea3c372394258bc6aed689b1e4a38/Untitled.png)
    

### 思路：

其实本质上还是dp问题，和传统的LIS问题思路几乎一致（毫无疑问的没想出来，cai）只需要将原来的模板稍加改造即可。

要解决因子的问题，我们可以联想一下还有什么地方用到了因子？显然是埃氏筛，我们对于每个数在n范围内的倍数进行dp推演就可以了。当然，相似的，也可以使用倍数解决。

注意：每次推演的仅仅针对于两个数，并不是一次解决一串。之前一直陷入在希望一次直接生成一串互相为因数的序列然后直接遍历的误区中，感觉就像装上的一块铁板，这个时候还是需要转变一下思维，将长序列拆分成两个数之间的关系，当然这个也是dp的关键思维。

- 筛选因子
    
    ```cpp
    int main(){
        cin>>t;
        while(t--){
            cin>>n;
            for(int i=1;i<n;i++){
                cin>>a[i];
                dp[i]=1;
            }
            int ans=1;
            for(int i=2;i<=n;++i){
                if(a[i]>a[1])
                    dp[i]=max(dp[i],dp[1]+1);
                for(int j=2;j*j<=i;++j){
                    if(i%j==0){//直接标记所有因子
                        if(a[i]>a[j])
                            dp[i]=max(dp[i],dp[j]+1);
                        if(a[i]>a[i/j])
                            dp[i]=max(dp[i],dp[i/j]+1);
                    }
                }
                ans=max(dp[i],ans);
            }
            cout<<ans<<endl;
        }
        return 0;
    }
    ```
    
- 使用倍数
    
    ```cpp
    #include<bits/stdc++.h>
    
    using namespace std;
    int arr[1000000];
    int dp[1000000];
    
    int main() {
        int n, m;
        scanf("%d", &n);
        while (n--) {
            int ans = 1;
            scanf("%d", &m);
            for (int i = 1; i <= m; i++)
                scanf("%d", arr + i);
            for (int i = 1; i <= m; i++)
                dp[i] = 1;
            int l = m / 2;
            for (int i = 1; i <= l; i++)
                for (int j = i; j <= m; j += i)
                    if (arr[i] < arr[j])
                        dp[j] = dp[j] > dp[i] + 1 ? dp[j] : dp[i] + 1;
            for (int i = 1; i <= m; i++)
                ans = ans > dp[i] ? ans : dp[i];
            printf("%d\n", ans);
        }
    }
    ```