How to make it: On My Own
Tags: Simulate
Time Created: October 13, 2021 11:19 PM

## 象棋

- [1589.pdf (onlinejudge.org)](https://onlinejudge.org/external/15/1589.pdf)

### 总结：

1. 题目本身不是很难，但是有许多特殊的情况需要考虑（黑方能在开局直接把红方一枪秒了（飞将）是我没想到的），如果以后思维还是这样不缜密，很容易阴沟翻船。
2. 其次是对算法的选择，本来打算是先读取所有的红方棋子，然后将黑方不能步入区域进行标记（其实我觉的如果能按第一个方案走下来的话，一次ac的几率是很大的）但是由于这个方法实在是太麻烦了，分的步骤巨多，于是就放弃了。转而选用根据红方将的位置进行搜索，分别对行，列，马的情况进行判定。写起来就方便多了！以后注意还是要先较为完整的设计完整个算法，再开始写！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！

### AC Code

```
//xiang qi//Author：Suxton#include <stdio.h>#include <string.h>#include <math.h>int pa[11][12];int po[4][2][2];//G[0];jiang 0//C[1];pao 1//R[2];che 2//H[3];ma 3char readchar() {    char ch = getchar();    if (ch == '\n' || ch == '\r' || ch == ' ') return readchar();    else return ch;}int chkrow(int a, int b) {    //chkpao    int counter;    for (int i = 0; i < 2; i++) {        counter = 0;        if (po[1][1][i] == b) {            if (po[1][1][i] == a) continue;            if (po[1][0][i] < a) {//left side                for (int j = po[1][0][i] + 1; j < a; j++)                    if (pa[j][b]) counter++;                if (counter == 1) return 1;            } else {                for (int j = a + 1; j < po[1][0][i]; j++)                    if (pa[j][b]) counter++;                if (counter == 1) return 1;            }        }    }    //chkche    for (int i = 0; i < 2; i++) {        counter = 0;        if (po[2][1][i] == b) {            if (po[2][0][i] == a) continue;            if (po[2][0][i] < a) {                for (int j = po[2][0][i] + 1; j < a; j++)                    if (pa[j][b]) counter++;                if (counter == 0) return 1;            } else {                for (int j = a + 1; j < po[2][0][i]; j++)                    if (pa[j][b]) counter++;                if (counter == 0) return 1;            }        }    }    return 0;}int chkclu(int a, int b) {    //chkjiang    int counter = 0;    if (po[0][0][0] == a) {        for (int i = po[0][1][0] - 1; i > b; i--) {            if (pa[po[0][0][0]][i]) counter++;            if (counter > 0) break;        }        if (!counter) return 1;    }    //chkpao    for (int i = 0; i < 2; i++) {        counter = 0;        if (po[1][0][i] == a) {            if (po[1][1][i] == b) continue;            if (po[1][1][i] > b) {                for (int j = po[1][1][i] - 1; j > b; j--)                    if (pa[a][j]) counter++;                if (counter == 1) return 1;            } else {                if (po[1][1][i] == 1 && pa[a][2]) return 1;            }        }    }    //chkche    for (int i = 0; i < 2; i++) {        counter = 0;        if (po[2][0][i] == a) {            if (po[2][1][i] == b) continue;            if (po[2][1][i] > b) {                for (int j = po[2][1][i] - 1; j > b; j--)                    if (pa[a][j]) counter++;                if (counter == 0) return 1;            } else {                if (po[2][1][i] == b - 1) return 1;                if (po[2][1][i] == 1 && b == 3 && !pa[a][2]) return 1;            }        }    }    return 0;}int chkma(int a, int b) {//(6,2)(4,3)    int result = 0;    for (int i = 0; i < 2; i++) {        if (po[3][0][i] == a && po[3][1][i] == b) continue;        if (po[3][0][i] == 0) continue;        int dx = po[3][0][i] - a;        int dy = po[3][1][i] - b;        if (abs(dx) == 2 && abs(dy) == 1) {            int tx = (a + po[3][0][i]) / 2;            if (pa[tx][po[3][1][i]] == 0) {                result = 1;                //printf("%d %d",tx,result);            }        } else if (abs(dx) == 1 && abs(dy) == 2) {            int ty = (b + po[3][1][i]) / 2;            if (pa[po[3][0][i]][ty] == 0) result = 1;        }    }    return result;}int main() {    int r, a, b;// num of red & BG(row,clum)    while ((scanf("%d%d%d", &r, &b, &a) == 3) && r) {        memset(pa, 0, sizeof(pa));        memset(po, 0, sizeof(po));        int C = 0, H = 0, R = 0;        while (r--) {            switch (readchar()) {                case 'G':                    scanf("%d%d", &po[0][1][0], &po[0][0][0]);                    break;                case 'C':                    scanf("%d%d", &po[1][1][C], &po[1][0][C]);                    //if (po[1][0][C] > 3 && po[1][0][C] < 7 && po[1][1][C] > 0 && po[1][1][C] < 4)                    pa[po[1][0][C]][po[1][1][C]] = 1;                    C++;                    break;                case 'R':                    scanf("%d%d", &po[2][1][R], &po[2][0][R]);                    //if (po[2][0][R] > 3 && po[2][0][R] < 7 && po[2][1][R] > 0 && po[2][1][R] < 4)                    pa[po[2][0][R]][po[2][1][R]] = 1;                    R++;                    break;                case 'H':                    scanf("%d%d", &po[3][1][H], &po[3][0][H]);                    //if (po[3][0][H] > 3 && po[3][0][H] < 7 && po[3][1][H] > 0 && po[3][1][H] < 4)                    pa[po[3][0][H]][po[3][1][H]] = 1;                    H++;                    break;            }        }        //judge now        int counter = 0;//win in a single move        if (po[0][0][0] == a) {            for (int i = po[0][1][0] - 1; i > b; i--) {                if (pa[a][i]) counter++;                if (counter > 0) break;            }            if (!counter) {                printf("NO\n");                continue;            }        }        //judge 4 direction        if (a != 6) {//move right            if (chkclu(a + 1, b) == 0 && chkma(a + 1, b) == 0 && chkrow(a + 1, b) == 0) {                printf("NO\n");                continue;            }        }        if (a != 4) {//move left            if (chkclu(a - 1, b) == 0 && chkma(a - 1, b) == 0 && chkrow(a - 1, b) == 0) {                printf("NO\n");                continue;            }        }        if (b != 1) {//move up            if (chkclu(a, b - 1) == 0 && chkma(a, b - 1) == 0 && chkrow(a, b - 1) == 0) {                printf("NO\n");                continue;            }        }        if (b != 3) {//move down            if (chkclu(a, b + 1) == 0 && chkma(a, b + 1) == 0 && chkrow(a, b + 1) == 0) {                printf("NO\n");                continue;            }        }        printf("YES\n");    }}
```