How to make it: Tutorial
Tags: DP, Math
Time Created: September 15, 2022 11:33 PM

[E - Average and Median (atcoder.jp)](https://atcoder.jp/contests/abc236/tasks/abc236_e)

**思路：**

    对于单调找值的问题，都可以采用 **二分** 的方法，而且找到的数字不一定在数组之中。于是我们可以在 $0$ 到 数组最大值的区间中二分。

- 平均值越小选择就越多，于是我们通过判断我们当前得到的平均值是否能够由当前数组得到，如果可以的话就增加，不行的话就减小。具体来说就是将每个数字和当前的平均数相减得到一个新的数，如果得到的数是负的的话，说明这个数缺少的数需要其他数来补上，于是最后得到的结果如果是正的话，说明这个平均数可能得到，如果等于0的话，说明一定能得到。
- 中位数的话其他数的影响并不大，影响大的是数字排列的顺序，于是我们直接判断每个数是否大于当前的中位数，是的话加上 $1$ ，不是的话加上 $-1$ 。如果最终的结果能大于0就说明结果大于等于当前的中位数。

    题目还有个要求，每两个相邻的格子要选一个。于是可以使用二维的dp解决。

- Code
    
    ```cpp
    #include <bits/stdc++.h>
    
    #define int long long
    #define mod 1000000007
    #define MAXN 100005
    #define endl '\n'
    using namespace std;
    #define IO ios::sync_with_stdio(false);\
        cin.tie(nullptr)
    double mx = 0;
    typedef pair<char, int> pii;
    
    ostream &operator<<(ostream &o, pii p) {
        o << '<' << (int) p.first << ',' << (int) p.second << '>';
        return o;
    }
    
    template<typename T>
    ostream &operator<<(ostream &o, vector<T> &x) {
        o << "[";
        for (auto i = x.begin(); i < x.end(); ++i) {
            if (i != x.begin()) o << ", ";
            o << *i /*<< ' '*/;
        }
        o << "]" << endl;
        return o;
    }
    
    template<typename T>
    istream &operator>>(istream &i, vector<T> &v) {
        for (auto it = v.begin(); it < v.end(); ++it) {
            cin >> *it;
            mx = max(mx, *it);
        }
        return i;
    }
    
    void solve() {
        int n;
        cin >> n;
        vector<double> v(n), a(n);
        cin >> v;
    
        //0 for not selected
        vector<vector<double>> dp(2, vector<double>(n));
    
        function<double()> chk = [&]() {
            for (int i = 1; i < n; i++) {
                dp[0][i] = dp[1][i - 1];
                dp[1][i] = max(dp[0][i - 1], dp[1][i - 1]) + a[i];
            }
            return max(dp[1][n - 1], dp[0][n - 1]);
        };
    
        double l = 0.0, r = mx+10;
        while (r - l > 1e-5) {
            double mid = (l + r) / 2;
    
            dp[1][0] = a[0];
            for (int i = 0; i < n; i++)
                a[i] = v[i] - mid;
    
            if (chk() >= 0) l = mid;
            else r = mid;
        }
        cout << r << endl;
        int ll = 1, rr = (int) mx;
        while (rr > ll) {
            int mid = (ll + rr + 1) >> 1;
    
            dp[1][0] = v[0] >= mid ? 1 : -1;
            for (int i = 0; i < n; i++)
                a[i] = v[i] >= mid ? 1 : -1;
    
            if (chk() > 0) ll = mid;
            else rr = mid - 1;
        }
        cout << rr;
    
    }
    
    signed main() {
        IO;
        int T = 1;
    //    cin >> T;
        while (T--) {
            solve();
        }
        return 0;
    }
    ```