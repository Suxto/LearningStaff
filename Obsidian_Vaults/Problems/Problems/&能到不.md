How to make it: Tutorial
Tags: DP
Time Created: September 30, 2022 12:28 AM

[https://codeforces.com/problemset/problem/1168/C](https://codeforces.com/problemset/problem/1168/C)

**思路**：

    对于这个题，一个十分关键的点是，如果想要到达目标数，那么在行进的路线上，每一个数都需要有一个二进制位是 `1` ，那么就可以将这个题简化。假如目标数的第 `i` 位是 `1` ，那么如果从起点开始，最左边第 `i` 位为 `1` 的数（不超过起始点）的坐标小于终点的话，就可以到达终点。

    为了能在询问时在 $O(1)$ 的时间复杂度下得到答案，我们需要建立数组 `dp[i][bit]` ，第一个数值得是起始点的坐标，第二个数指的是第 `pos` 位为 `1` 。存的是离 `i` 最近的第 `bit` 位为 `1` 的数字下标。为了得到这个数组，我们需要倒着计算，并且在计算的过程中，更新 `last` 数组（存入的是第 `bit` 位为 `1` 的数的最左边的下标。于是有转移方程 `dp[i][bit]=min(dp[i][bit],dp[last[bit][bit])` 。

- Code
    
    ```cpp
    #include <bits/stdc++.h>
    
    #define int long long
    #define MOD 10000007
    #define MAXN 1000005
    #define endl '\n'
    using namespace std;
    #define IO ios::sync_with_stdio(false);\
        cin.tie(nullptr)
    
    template<typename T>
    ostream &operator<<(ostream &o, vector<T> &x) {
        o << "[";
        for (auto i = x.begin(); i < x.end(); ++i) {
            if (i != x.begin()) o << ", ";
            o << *i /*<< ' '*/;
        }
        o << "]" << endl;
        return o;
    }
    
    template<typename T>
    istream &operator>>(istream &i, vector<T> &v) {
        for (auto it = v.begin(); it < v.end(); ++it) {
            cin >> *it;
    //        mx = max(mx, *it);
        }
        return i;
    }
         
    
    void solve() {
        int n, m;
        cin >> n >> m;
        vector<int> v(n), lst(20);
        vector<vector<int>> dp(n, vector<int>(20, LLONG_MAX));//dp[i][bit]
        cin >> v;
        auto calc = [&](const int &x) {
            for (int i = 0; i < 20; i++) {
                if ((v[x] >> i) & 1) {
                    dp[x][i] = x;
                    if (lst[i]) {
                        for (int j = 0; j < 20; j++) {
                            dp[x][j] = min(dp[x][j], dp[lst[i]][j]);
                        }
                    }
                    lst[i] = x;
                }
            }
        };
        for (int i = v.size() - 1; i > -1; i--) {
            calc(i);
        }
        auto judge = [&](const int &l, const int &r) {
            for (int i = 0; i < 20; i++) {
                if ((v[r] >> i) & 1 && dp[l][i] <= r) return true;
            }
            return false;
        };
        while (m--) {
            int l, r;
            cin >> l >> r;
            if (judge(l - 1ll, r - 1ll))cout << "Shi\n";
            else cout << "Fou\n";
        }
    }
    
    signed main() {
        IO;
        int T = 1;
    //    cin >> T;
        while (T--) {
            solve();
        }
        return 0;
    }
    ```