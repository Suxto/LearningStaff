How to make it: Tutorial
Tags: Binary
Time Created: June 18, 2022 12:41 AM

[Problem - E - Codeforces](https://codeforces.com/contest/1692/problem/E)

## 思路：

    一看到这种求和的就知道要用前置和，求字串用双指针。我们只要枚举左边的指针再二分右边的指针就可以得到一个符合条件的字串。

**注意**：

- 多使用一个变量来存储二分的结果，防止它意外移动。
- 使用前置和求区间$[l,r]$的时候应该是$preSum[r]-preSum[l-1]$。当$l=0$的时候，要将后面的那一项变为$0$。

## code

```cpp
#include <bits/stdc++.h>

using namespace std;
#define  endl '\n'
#define int long long

int num, obj;

int count(int l, int r, vector<int> &preSum) {
    return preSum[r] - (l ? preSum[l - 1] : 0);
}

int binSer(int ol, vector<int> &preSum) {
    int r = num - 1, l = ol, pos = -1;
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (count(ol, mid, preSum) <= obj) {//upper
            l = mid + 1;
            pos = mid;
        } else r = mid - 1;
    }
    if (pos == -1 || count(ol, pos, preSum) != obj) return -1;
    else return pos;
}

void solve() {
    cin >> num >> obj;

    vector<int> v(num), preSum(num);

    cin >> v[0];
    preSum[0] = v[0];

    for (int i = 1; i < num; i++) {
        cin >> v[i];
        preSum[i] = v[i] + preSum[i - 1];
    }

    if (preSum[num - 1] < obj) {
        cout << -1 << endl;
        return;
    }

    int ans = 0ll;

    for (int i = 0; i < num; i++) {
        int r = binSer(i, preSum);
        if (r == -1) continue;
        ans = max(r - i + 1, ans);
    }

    cout << num - ans << endl;
}

signed main() {
    cin.tie(nullptr)->sync_with_stdio(false);
    int t = 1;
//	scanf("%d", &t);
    cin >> t;
    while (t--) solve();
}
```