How to make it: Tutorial
Tags: DFS, Graph
Time Created: May 28, 2022 9:49 AM

[Problem - 931D - Codeforces](https://codeforces.com/problemset/problem/931/D)

## 思路

    将苹果树本质上是一棵树（废话），可以使用父节点+子节点的方式存储（二维数组）。然后使用DFS来判断每一个节点的深度。有了深度的信息之后，只要数出某一层的苹果个数，看看他们是奇数还是偶数，就能得到 `ans` 的大小。

**例子：**

样例2：

> 5
1 2 2 2
> 

图的记录方式：

> 1: 2
> 
> 
> 2: 3, 4, 5
> 

显然： `1` 在第一层， `2` 在第二层， `3,4,5` 在第三层

每层的个数都是奇数，于是答案为 `3` 

- code
    
    ```cpp
    #include <bits/stdc++.h>
    
    #define mod 1000000007
    #define MAXN 1000005
    typedef int64_t ll;
    #define endl '\n'
    #define N 7
    using namespace std;
    #define IO ios::sync_with_stdio(false);\
        cin.tie(0),cout.tie(0)
    
    vector<int> G[MAXN];
    int lay[MAXN], n;
    
    void dfs(int pre, int now) {
        lay[now] = lay[pre] + 1;
        for (int v: G[now]) {
            if (v != now) {
                dfs(now, v);
            }
        }
    }
    
    int main() {
        IO;
        int ans = 0;
        cin >> n;
        vector<int> v(n + 1);
        v[0] = 1;
        for (int i = 2; i <= n; i++) {
            cin >> v[i];
            G[v[i]].emplace_back(i);
        }
        dfs(0, 1);
        map<int, int> m;
        for (int i = 1; i <= n; i++) {
            m[lay[i]]++;
        }
        for (auto &i: m) {
            if (i.second & 1)ans++;
        }
        cout << ans;
    }
    ```