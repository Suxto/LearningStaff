How to make it: Tutorial
Tags: DFS, Graph
Time Created: July 16, 2022 8:51 PM

[Problem - E - Codeforces](https://codeforces.com/contest/1702/problem/E)

### 思路：

    这道题有两个思路，查并集和二分图

1. 并查集：通过记录每个数字在哪两个组中出现过，然后将两个组的编号分别加入对方的仇人列表，代表同一个数字（实际上是它的组）不能在同一个堆中出现两次。当一个数字出现的两个组的编号处于同一个集合的时候，说明这个数所处的两个组都和同一个组存在相同的数字，就不能把这个组放在有相同数字的堆，然而都放在另一个堆的话当前数字就会在这个堆中出现两次，导致不符合题意。
    
    [并查集](https://www.notion.so/1593deb0144b4b288bbf17eb4cbd902f)
    
2. 二分图：题目说提供的骨牌上面的数字都 **不超过n** 这一点很重要，那么要分成两堆的话，相当于两堆里面都需要有从1到n的数字。我们将牌上的数字进行清点，每一个在$[1,n]$的数字都要出现。这个操作可以抽象为判断所有的点组成的图是不是二分图，而且每一张二分图上面都有两条连线（每一个数字出现两次）。
- Code 1
    
    ```cpp
    #include<bits/stdc++.h>
    
    #define MAXN 200020
    #define int long long
    #define endl '\n'
    #define IO cin.tie(nullptr)->sync_with_stdio(0)
    using namespace std;
    
    typedef pair<int,int> pii;
    int arr[400020];
    vector<int> v[MAXN];
    
    int find(int x) {
        if (arr[x] == x)return x;
        arr[x] = find(arr[x]);
        return arr[x];
    }
    
    inline void merge(int x, int y) {
        arr[find(x)] = find(y);
    }
    
    void solve() {
        int num;
        cin >> num;
        vector<pii> vp;
        for(int i=0;i<=num;i++){
            arr[i]=i;
            v[i].clear();
        }
        for (int i = num;i <= 2 * num;i++) {
            arr[i] = i;
        }
        for(int i=1;i<=num;i++){
            int x,y;
            cin>>x>>y;
            v[x].emplace_back(i);
            v[y].emplace_back(i);
        }
        for(int i=1;i<=num;i++){
            if(v[i].size()==2){
                vp.emplace_back(v[i][0],v[i][1]);
            }else {
                cout<<"NO"<<endl;
                return;
            }
        }
        for(auto &[x,y]:vp){
            if(find(x)==find(y)){
                cout<<"NO"<<endl;
                return;
            }
            merge(x,y+num);
            merge(y,x+num);
        }
        cout<<"YES"<<endl;
    }
    
    signed main() {
        IO;
        int T = 1;
        cin>>T;
        while (T--) solve();
        return 0;
    }
    ```
    
- Code 2
    
    ```cpp
    #include <bits/stdc++.h>
    
    #define MAXN 200020
    #define int long long
    #define endl '\n'
    #define IO cin.tie(nullptr)->sync_with_stdio(0)
    using namespace std;
    
    typedef pair<int, int> pii;
    vector<int> v[MAXN];
    
    bool isBipartite(vector<int> v[], int n) {
      vector<int> col(n + 2, -1); //-1 for not colored
    
      queue<int> q;
    
      for (int i = 1; i <= n; i++) {
        if (col[i] == -1) {
          q.push(i);
          col[i] = 0;
          while (!q.empty()) {
            // auto [ve, c] = q.front();
            int cur = q.front();
            int c = col[cur] == 0 ? 1 : 0;
            q.pop();
            for (int &j : v[cur]) {
              if (col[j] == -1) {
                col[j] = c;
                q.push(j);
              }
              if (col[j] != c)
                return false;
            }
          }
        }
      }
      return true;
    }
    
    void solve() {
      int n;
      cin >> n;
      for (int i = 1; i <= n; i++) {
        v[i].clear();
      }
      for (int i = 0; i < n; i++) {
        int x, y;
        cin >> x >> y;
        v[x].emplace_back(y);
        v[y].emplace_back(x);
      }
      for (int i = 1; i <= n; i++)
        if (v[i].size() != 2) {
          cout << "NO\n";
          return;
        }
      if (isBipartite(v, n))
        cout << "YES\n";
      else
        cout << "NO\n";
    }
    
    signed main() {
      IO;
      int T = 1;
      cin >> T;
      while (T--)
        solve();
      return 0;
    }
    ```