How to make it: Tutorial
Tags: Slide Window
Time Created: May 5, 2022 8:39 PM

[D - Longest X (atcoder.jp)](https://atcoder.jp/contests/abc229/tasks/abc229_d?lang=en)

### 思路：

    使用滑窗算法，这个算法的关键在于每次不将右端点置零，这样就能够节约很多的的时间（上次右边走到的位置如果左边前进一个后重新走的话显然会更远）。再加上前置和的使用，可以很快得（$O(1)$）知当前这个点是否超过了 `k` 的上限。

**注意：**如果不对数组做任何处理直接算前置和的话会出现一个问题，如果前置和中是 `.` 的位置减去 `.` 的位置，那么会少算一个（其他情况均正常）。因为两个都位置都处于 `+1` 的状态，相减的话会把 `+1` 抵消掉，为了避免这样的情况出现，我们可以将 `l` 滞后一个。如果 `l` 正好在 `x` 上，由于不消耗 `k` 就可以相当于白给。如果 `l` 在 `.` 上，滞后了一个相当于 `+1` 的操作，就给补回来了。

- code
    
    ```cpp
    #include<bits/stdc++.h>
     
    using namespace std;
    typedef int64_t ll;
    using namespace std;
    #define MAXN 100010
    #define endl '\n'
    #define IO ios::sync_with_stdio(false);\
    cin.tie(0), cout.tie(0);
     
     
    int main() {
        IO
        ll k, len;
        string s;
        cin >> s;
        cin >> k;
        len = s.length();
        ll ans = 0;
        vector<ll> v(len + 1);
     
    //    if (s[0] == '.') v[0] = 1;
    //    else v[0] = 0;
     
        for (ll i = 0; i < len; i++) {
            if (s[i] == '.') v[i + 1] = v[i] + 1;
            else v[i + 1] = v[i];
        }
        ll r = 0ll;
        //xx...x.x.x.
        //000123344556
        for (ll l = 0; l < len; l++) {
            while (r < len && v[r + 1] - v[l] <= k) r++;
            ans = max(ans, r - l);
        }
        cout << ans;
    }
    ```