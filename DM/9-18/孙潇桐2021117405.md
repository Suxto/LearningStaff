# 9-18作业

#### 1. 简述设计多最小支持度关联规则挖掘算法的动机。

需要避免由于最小支**持度阈值设置过低**而产生众多无意义关联规则的同时，又能顺利的**对稀有项目就行挖掘**。

然而，当面对大规模数据集时，传统算法的性能会受到限制。计算**频繁项集**的过程可能需要遍历**大量的数据**，导致计算复杂度较高。此外，由于数据集的规模增加，频繁项集的数量也会增加，导致**存储和处理频繁项集**的开销变得更大。

#### 2.多最小支持度关联规则挖掘有什么特点？

对每个项目都指定一个**最小项目支持度**，不同的项集根据所包含的项目的不同需要满足不同的最小支持度。每个频繁项集中的项目的支持度都**大于项集中的最小MIS**。

多最小支持度算法可以通过使用不同的最小支持度阈值在多个支持度级别上挖掘频繁项集和关联规则。这样可以发现不同支持度级别下的有趣规则，并提供更全面的数据挖掘结果。不同的最小支持度阈值可以根据具体的需求和数据特征进行选择，从而提供更多的灵活性和多样性。

多最小支持度算法对于大**规模数据集具有较好的可扩展性**。由于可以根据数据集的特点选择不同的最小支持度阈值，算法可以适应不同规模的数据集。这种可扩展性使得多最小支持度算法在处理大规模数据时更具优势，并且能够应对不断增长的数据量。

#### 3.简述多最小支持度关联规则挖掘的算法过程。

1. 为每个项目指定一个MIS
2. 根据MIS对项目进行**排序**
3. 生成候选项集$$L$$和频繁项集$$F_1$$
4. 每次使用上一次的频繁项集生成新的候选项集
5. 对新的候选项集，计算支持度，得到频繁项集
6. 再通过频繁项集生成规则即可

#### 4.假设有1，2，3，4总共四个项目，其最小支持度分别为MIS(1) = 10%   MIS(2) = 20%  MIS(3) = 5%   MIS(4) = 6% ，事务数据集大小为100，四个项目的实际支持度分别为{3}.count = 6, {4}.count = 3,  {1}.count = 9, {2}.count = 25，则1频繁候选集L和真实的1频繁项集F1分别为？

+ $$L$$: {3, 1, 2}
+ $$F_1$$: {{3}, {2}}
+ 详细过程：

    + 频繁候选集L和真实的1频繁项集F1。

        首先，根据最小支持度，计算每个项目的最小支持计数（Minimum Support Count）：

        MIS(1) = 10% * 100 = 10
        MIS(2) = 20% * 100 = 20
        MIS(3) = 5% * 100 = 5
        MIS(4) = 6% * 100 = 6

        然后，根据最小支持计数和实际支持度，筛选出频繁候选集L：

        L1 = {3, 1, 2}

        因为每个项目的实际支持度都大于等于其对应的最小支持计数。

        最后，根据频繁候选集L和实际支持度，确定真实的1频繁项集F1：

        F1 = {{3}, {2}}

        因为{1}.count = 9 <= MIS(1) = 10。{3}.count = 6 >= MIS(3) = 5，{4}.count = 3 >= MIS(4) = 6。


#### 5.分类关联规则挖掘和关联规则挖掘的区别之处在于？

1. 后件和前件来自不同的集合，后项均为类别
2. 分类关联的后项只有**一个项目**
3. 关联规则挖掘的目标是发现数据**集中项之间的相关性和关联规律**。它通过分析数据集中的频繁项集和关联规则，揭示不同项之间的关联关系。而分类关联规则挖掘的目标是将数据集中的实例或样本划分到不同的类别中。它在挖掘关联规则的基础上，进一步**将规则应用于分类任务**，用于预测新样本的类别。
4. 关联规则挖掘通常使用支持度和置信度等指标来度量项集之间的关联程度。它主要关注项之间的频繁出现和关联程度。而分类关联规则挖掘则需要考虑类别标签之间的关联性，并结合分类算法进行预测。它关注的是项集与类别标签之间的关联关系。

#### 6.设I = {1, 2, 3, 4, 5, 6, 7, 8, 9}，有序列s1=<{7}{4, 8}{8}>和s2= <{6} {3, 7}{9}{4, 5, 8}{3, 8}>，则s1是否是s2的子序列？简述理由。分别给出s1和s2的基数和长度。

是。因为$$\{7\}\subseteq \{3, 7\}$$、$$\{4,8\}\subseteq \{4,5, 8\}$$、$$\{8\}\subseteq \{3, 8\}$$。

s1的基数是3，长度是4

s2的基数是5，长度是9

详细过程：
理由是，s1中的每个项都可以在s2中按照相同的顺序找到。具体来说，s1可以通过在s2中去除一些项和调整项的顺序来得到。s1中的第一个项{7}可以在s2中找到，然后s2中的项{4, 8}可以在s2中的第二个和第三个项中找到，最后s2中的第四个项{8}也可以在s2中找到。

#### 7.给定3-频繁序列：<{1,2} {4}> <{1,2} {5}> <{1} {4,5}> <{1,4} {6}> <{2} {4,5}> <{2} {4} {6}>，给出合并后的4-频繁序列的候选集以及剪枝后的4-频繁序列的候选集，简述合并和剪枝过程。

+ 候选集：<{1,2}, {4,5}> (<{1,2} {4}> + <{2} {4,5}>)          <{1,2}, {4}, {6}>(<{1,2} {4}>  + <{2} {4} {6}>)[不存在<{1} {4} {6}>，所以剪掉]

+ 剪枝后：<{1,2}, {4,5}> 

+ 详细过程：

    + 合并过程：

        + 首先，比较序列<{1,2} {4}>和<{2} {4,5}>，它们的<{2,4}>相同，因此可以将它们合并为<{1,2}, {4,5}>。

        + 然后，比较序列<{1,2} {4}>和<{2} {4} {6}>，它们<2,4>的相同，所以合并为<{1,2} {4} {6}>。

            剪枝过程：

    + 对于候选序列<{1,2} {4,5}>，检查它的子序列是否都是3-频繁的。子序列<{1,2} {4}>和<{1,2} {5}>都是3-频繁的，因此保留该候选序列。

    + 

        最终的4-频繁序列的候选集为：<{1,2} {4,5}> <{1,4} {6}> <{2} {4,5,6}>
