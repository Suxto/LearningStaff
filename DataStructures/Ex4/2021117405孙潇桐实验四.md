# **实验四** **二叉树及其应用**

## 4.1二叉树遍历应用

打印图形的思路就是二叉树的逆中序遍历，根据递归的层数打印对应的空格数。编号设置则是后序遍历。

**运行截图：**

![image-20221107144101226](C:\Users\suxto\OneDrive\Documents\LearningStaff\DataStructures\Ex4\2021117405孙潇桐实验四\image-20221107144101226.png)

**代码**

```cpp
#include<iostream>

using namespace std;

struct node {
    node *lChild = nullptr, *rChild = nullptr;
    char data = 0;
    int num = 0;

    friend ostream &operator<<(ostream &o, node *n) {
        cout << n->data << n->num;
        return o;
    }
};

void build(node *now, char ch) {
    now->data = ch;
    char chr = static_cast<char>(cin.get());
    if (chr != ' ') {
        now->lChild = new node;
        build(now->lChild, chr);
    }
    chr = static_cast<char>(cin.get());
    if (chr != ' ') {
        now->rChild = new node;
        build(now->rChild, chr);
    }
}

void print(node *now, int lay = 0) {
//    cout.put(now->data);
//    cout.put((now->num) + '0');
    if (now == nullptr) return;
    print(now->rChild, lay + 1);
    for (int i = 0; i < lay; i++)cout << "   ";
    cout << now << ' ' << endl;
    print(now->lChild, lay + 1);

}

void count(node *now) {
    static int cnt = 0;
    if (now == nullptr) return;
    count(now->lChild);
    count(now->rChild);
    now->num = ++cnt;
}

int main() {
    node *head = new node;
    build(head, static_cast<char>(cin.get()));
    count(head);
    print(head);
}
// AB D  CE F

```

## 4.2 二叉树遍历与栈、队列

我选择第二小题：输入某元素结点，输出从二叉树根结点到该结点之间的路径序列。

思路是使用先序遍历，找到需要找到的节点，然后再递归退层的时候将路上经过的点压入一个栈中，将栈的内容输出就得到了路径。

**运行截图**

![image-20221107145756080](C:\Users\suxto\OneDrive\Documents\LearningStaff\DataStructures\Ex4\2021117405孙潇桐实验四\image-20221107145756080.png)

![image-20221107145842751](C:\Users\suxto\OneDrive\Documents\LearningStaff\DataStructures\Ex4\2021117405孙潇桐实验四\image-20221107145842751.png)

输入的数据：

![image-20221107145933371](C:\Users\suxto\OneDrive\Documents\LearningStaff\DataStructures\Ex4\2021117405孙潇桐实验四\image-20221107145933371.png)

**代码：**

```cpp
#include<iostream>
#include <functional>

using namespace std;

template<typename T>
class myStack {
public:
    int topptr = 0;
    T *arr = nullptr;

    explicit myStack(int n) {
        arr = new T[n];
    }

    myStack() = default;

    [[nodiscard]] T top() const {
        return *(arr + topptr);
    };

    [[nodiscard]] bool empty() const {
        return topptr == 0;
    }

    void push(T x) {
        topptr++;
        *(arr + topptr) = x;
    }

    T pop() {
//        if (topptr == 0) return 0;
//        else
        return *(arr + topptr--);
    }

    friend ostream &operator<<(ostream &o, myStack &s) {
//        for (int i = 1; i <= s.topptr; i++) {
//            o << s.arr[i] << ' ';
//        }
        while (!s.empty())
            o << s.pop() << ' ';
        return o;
    }
};

struct node {
    node *lChild = nullptr, *rChild = nullptr;
    int data = 0;

    friend ostream &operator<<(ostream &o, node *n) {
        cout << n->data;
        return o;
    }
};


void build(node *now, int ch) {
    now->data = ch;
    int chr;
    cin >> chr;
    if (chr != 0) {
        now->lChild = new node;
        build(now->lChild, chr);
    }
    cin >> chr;
    if (chr != 0) {
        now->rChild = new node;
        build(now->rChild, chr);
    }
}

void print(node *now, int lay = 0) {
//    cout.put(now->data);
//    cout.put((now->num) + '0');
    if (now == nullptr) return;
    print(now->rChild, lay + 1);
    for (int i = 0; i < lay; i++)cout << "   ";
    cout << now << ' ' << endl;
    print(now->lChild, lay + 1);
}


int main() {
    //1 2 0 4 0 0 3 5 0 6 0 0 0
    node *head = new node;
    int x;
    cin >> x;
    build(head, x);
    cin >> x;
    auto stack = myStack<int>(100);
    function<bool(node *, int)> dfs = [&](node *now, int x) {
        if (now == nullptr) return false;
        if (now->data == x) {
            stack.push(now->data);
            return true;
        }
        if (dfs(now->lChild, x)) {
            stack.push(now->data);
            return true;
        }
        if (dfs(now->rChild, x)) {
            stack.push(now->data);
            return true;
        }
        return false;
    };
    dfs(head, x);
//    stack.push(head->data);
    cout << stack;
}

```

## 4.3 二叉树与树的关系

这题比较麻烦的点在于将树变成二叉树，我使用了邻接表法存储了树。然后通过广度优先搜索将树转换成了二叉树，然后再对二叉树进行前序遍历就能得到结果了。

**运行截图：**

![image-20221110230653778](C:\Users\suxto\OneDrive\Documents\LearningStaff\DataStructures\Ex4\2021117405孙潇桐实验四\image-20221110230653778.png)

其中输入数据的原本形式（左）和二叉树形式（右）：

![image-20221110230809396](C:\Users\suxto\OneDrive\Documents\LearningStaff\DataStructures\Ex4\2021117405孙潇桐实验四\image-20221110230809396.png)

**代码：**

```Cpp
#include <iostream>
#include <functional>
#include <vector>
#include <queue>

using namespace std;

ostream &space(ostream &o, int x) {
    for (int j = 0; j < x; j++) {
        o << "  ";
    }
    return o;
}


int main() {
    int n;
    cin >> n;
    vector<vector<int>> tree(n + 1);
    char tmp[3];
    for (int i = 1; i < n; i++) {
        cin >> tmp;
        int x = tmp[0] - 'A' + 1;
        cin >> tmp;
        int y = tmp[0] - 'A' + 1;
        tree[x].emplace_back(y);
        tree[y].emplace_back(x);
    }
    vector<int> bin(30, -1);

    auto bfs = [&](int fst) {
        vector<int> vis(n + 1);
        std::queue<int> q;
        q.push(fst);
        vis[fst] = fst;
        bin[fst] = fst;
        while (!q.empty()) {
            int now = q.front();
            int pos = vis[now];
            q.pop();
            bool first = true;
            for (const int &i: tree[now]) {
                if (vis[i]) continue;
                if (first) pos = pos << 1, first = false;
                else pos = (pos << 1) + 1;
                bin[pos] = i;
                vis[i] = pos;
                q.push(i);
            }
        }
    };
    bfs(1);
//
//    for (int i = 1; i <= 11; i++) cout << i << ' ';
//    cout << endl;
//    for (int i = 1; i <= 11; i++) cout << (char) (bin[i] + 'A' - 1) << ' ';
    function<void(int, int)> dfs = [&](int pos, int sp) {
        int l = pos << 1;
        int r = l + 1;
        space(cout, sp) << (char) (bin[pos] + 'A' - 1) << endl;
        if (bin[l] != -1) dfs(l, sp + 2);
        if (bin[r] != -1) dfs(r, sp);
    };
    dfs(1, 0);
    return 0;
}
/*
7
A B
A C
A D
B E
B F
C G
*/
```

## 4.4 哈夫曼编码

